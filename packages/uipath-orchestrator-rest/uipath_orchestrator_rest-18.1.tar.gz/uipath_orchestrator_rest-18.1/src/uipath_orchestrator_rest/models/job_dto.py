# coding: utf-8

"""
    UiPath.WebApi 18.0

    Orchestrator API  # noqa: E501

    OpenAPI spec version: 18.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from uipath_orchestrator_rest.configuration import Configuration


class JobDto(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'key': 'str',
        'start_time': 'datetime',
        'end_time': 'datetime',
        'state': 'str',
        'job_priority': 'str',
        'specific_priority_value': 'int',
        'robot': 'SimpleRobotDto',
        'release': 'SimpleReleaseDto',
        'resource_overwrites': 'str',
        'source': 'str',
        'source_type': 'str',
        'batch_execution_key': 'str',
        'info': 'str',
        'creation_time': 'datetime',
        'starting_schedule_id': 'int',
        'release_name': 'str',
        'type': 'str',
        'input_arguments': 'str',
        'output_arguments': 'str',
        'host_machine_name': 'str',
        'has_media_recorded': 'bool',
        'has_video_recorded': 'bool',
        'persistence_id': 'str',
        'resume_version': 'int',
        'stop_strategy': 'str',
        'runtime_type': 'str',
        'requires_user_interaction': 'bool',
        'release_version_id': 'int',
        'entry_point_path': 'str',
        'organization_unit_id': 'int',
        'organization_unit_fully_qualified_name': 'str',
        'reference': 'str',
        'process_type': 'str',
        'machine': 'MachineDto',
        'profiling_options': 'str',
        'resume_on_same_context': 'bool',
        'local_system_account': 'str',
        'orchestrator_user_identity': 'str',
        'remote_control_access': 'str',
        'starting_trigger_id': 'str',
        'max_expected_running_time_seconds': 'int',
        'serverless_job_type': 'str',
        'resume_time': 'datetime',
        'last_modification_time': 'datetime',
        'id': 'int'
    }

    attribute_map = {
        'key': 'Key',
        'start_time': 'StartTime',
        'end_time': 'EndTime',
        'state': 'State',
        'job_priority': 'JobPriority',
        'specific_priority_value': 'SpecificPriorityValue',
        'robot': 'Robot',
        'release': 'Release',
        'resource_overwrites': 'ResourceOverwrites',
        'source': 'Source',
        'source_type': 'SourceType',
        'batch_execution_key': 'BatchExecutionKey',
        'info': 'Info',
        'creation_time': 'CreationTime',
        'starting_schedule_id': 'StartingScheduleId',
        'release_name': 'ReleaseName',
        'type': 'Type',
        'input_arguments': 'InputArguments',
        'output_arguments': 'OutputArguments',
        'host_machine_name': 'HostMachineName',
        'has_media_recorded': 'HasMediaRecorded',
        'has_video_recorded': 'HasVideoRecorded',
        'persistence_id': 'PersistenceId',
        'resume_version': 'ResumeVersion',
        'stop_strategy': 'StopStrategy',
        'runtime_type': 'RuntimeType',
        'requires_user_interaction': 'RequiresUserInteraction',
        'release_version_id': 'ReleaseVersionId',
        'entry_point_path': 'EntryPointPath',
        'organization_unit_id': 'OrganizationUnitId',
        'organization_unit_fully_qualified_name': 'OrganizationUnitFullyQualifiedName',
        'reference': 'Reference',
        'process_type': 'ProcessType',
        'machine': 'Machine',
        'profiling_options': 'ProfilingOptions',
        'resume_on_same_context': 'ResumeOnSameContext',
        'local_system_account': 'LocalSystemAccount',
        'orchestrator_user_identity': 'OrchestratorUserIdentity',
        'remote_control_access': 'RemoteControlAccess',
        'starting_trigger_id': 'StartingTriggerId',
        'max_expected_running_time_seconds': 'MaxExpectedRunningTimeSeconds',
        'serverless_job_type': 'ServerlessJobType',
        'resume_time': 'ResumeTime',
        'last_modification_time': 'LastModificationTime',
        'id': 'Id'
    }

    def __init__(self, key=None, start_time=None, end_time=None, state=None, job_priority=None, specific_priority_value=None, robot=None, release=None, resource_overwrites=None, source=None, source_type=None, batch_execution_key=None, info=None, creation_time=None, starting_schedule_id=None, release_name=None, type=None, input_arguments=None, output_arguments=None, host_machine_name=None, has_media_recorded=None, has_video_recorded=None, persistence_id=None, resume_version=None, stop_strategy=None, runtime_type=None, requires_user_interaction=None, release_version_id=None, entry_point_path=None, organization_unit_id=None, organization_unit_fully_qualified_name=None, reference=None, process_type=None, machine=None, profiling_options=None, resume_on_same_context=None, local_system_account=None, orchestrator_user_identity=None, remote_control_access=None, starting_trigger_id=None, max_expected_running_time_seconds=None, serverless_job_type=None, resume_time=None, last_modification_time=None, id=None, _configuration=None):  # noqa: E501
        """JobDto - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._key = None
        self._start_time = None
        self._end_time = None
        self._state = None
        self._job_priority = None
        self._specific_priority_value = None
        self._robot = None
        self._release = None
        self._resource_overwrites = None
        self._source = None
        self._source_type = None
        self._batch_execution_key = None
        self._info = None
        self._creation_time = None
        self._starting_schedule_id = None
        self._release_name = None
        self._type = None
        self._input_arguments = None
        self._output_arguments = None
        self._host_machine_name = None
        self._has_media_recorded = None
        self._has_video_recorded = None
        self._persistence_id = None
        self._resume_version = None
        self._stop_strategy = None
        self._runtime_type = None
        self._requires_user_interaction = None
        self._release_version_id = None
        self._entry_point_path = None
        self._organization_unit_id = None
        self._organization_unit_fully_qualified_name = None
        self._reference = None
        self._process_type = None
        self._machine = None
        self._profiling_options = None
        self._resume_on_same_context = None
        self._local_system_account = None
        self._orchestrator_user_identity = None
        self._remote_control_access = None
        self._starting_trigger_id = None
        self._max_expected_running_time_seconds = None
        self._serverless_job_type = None
        self._resume_time = None
        self._last_modification_time = None
        self._id = None
        self.discriminator = None

        if key is not None:
            self.key = key
        if start_time is not None:
            self.start_time = start_time
        if end_time is not None:
            self.end_time = end_time
        if state is not None:
            self.state = state
        if job_priority is not None:
            self.job_priority = job_priority
        if specific_priority_value is not None:
            self.specific_priority_value = specific_priority_value
        if robot is not None:
            self.robot = robot
        if release is not None:
            self.release = release
        if resource_overwrites is not None:
            self.resource_overwrites = resource_overwrites
        if source is not None:
            self.source = source
        if source_type is not None:
            self.source_type = source_type
        if batch_execution_key is not None:
            self.batch_execution_key = batch_execution_key
        if info is not None:
            self.info = info
        if creation_time is not None:
            self.creation_time = creation_time
        if starting_schedule_id is not None:
            self.starting_schedule_id = starting_schedule_id
        if release_name is not None:
            self.release_name = release_name
        if type is not None:
            self.type = type
        if input_arguments is not None:
            self.input_arguments = input_arguments
        if output_arguments is not None:
            self.output_arguments = output_arguments
        if host_machine_name is not None:
            self.host_machine_name = host_machine_name
        if has_media_recorded is not None:
            self.has_media_recorded = has_media_recorded
        if has_video_recorded is not None:
            self.has_video_recorded = has_video_recorded
        if persistence_id is not None:
            self.persistence_id = persistence_id
        if resume_version is not None:
            self.resume_version = resume_version
        if stop_strategy is not None:
            self.stop_strategy = stop_strategy
        if runtime_type is not None:
            self.runtime_type = runtime_type
        if requires_user_interaction is not None:
            self.requires_user_interaction = requires_user_interaction
        if release_version_id is not None:
            self.release_version_id = release_version_id
        if entry_point_path is not None:
            self.entry_point_path = entry_point_path
        if organization_unit_id is not None:
            self.organization_unit_id = organization_unit_id
        if organization_unit_fully_qualified_name is not None:
            self.organization_unit_fully_qualified_name = organization_unit_fully_qualified_name
        if reference is not None:
            self.reference = reference
        if process_type is not None:
            self.process_type = process_type
        if machine is not None:
            self.machine = machine
        if profiling_options is not None:
            self.profiling_options = profiling_options
        if resume_on_same_context is not None:
            self.resume_on_same_context = resume_on_same_context
        if local_system_account is not None:
            self.local_system_account = local_system_account
        if orchestrator_user_identity is not None:
            self.orchestrator_user_identity = orchestrator_user_identity
        if remote_control_access is not None:
            self.remote_control_access = remote_control_access
        if starting_trigger_id is not None:
            self.starting_trigger_id = starting_trigger_id
        if max_expected_running_time_seconds is not None:
            self.max_expected_running_time_seconds = max_expected_running_time_seconds
        if serverless_job_type is not None:
            self.serverless_job_type = serverless_job_type
        if resume_time is not None:
            self.resume_time = resume_time
        if last_modification_time is not None:
            self.last_modification_time = last_modification_time
        if id is not None:
            self.id = id

    @property
    def key(self):
        """Gets the key of this JobDto.  # noqa: E501

        The unique job identifier.  # noqa: E501

        :return: The key of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._key

    @key.setter
    def key(self, key):
        """Sets the key of this JobDto.

        The unique job identifier.  # noqa: E501

        :param key: The key of this JobDto.  # noqa: E501
        :type: str
        """

        self._key = key

    @property
    def start_time(self):
        """Gets the start_time of this JobDto.  # noqa: E501

        The date and time when the job execution started or null if the job hasn't started yet.  # noqa: E501

        :return: The start_time of this JobDto.  # noqa: E501
        :rtype: datetime
        """
        return self._start_time

    @start_time.setter
    def start_time(self, start_time):
        """Sets the start_time of this JobDto.

        The date and time when the job execution started or null if the job hasn't started yet.  # noqa: E501

        :param start_time: The start_time of this JobDto.  # noqa: E501
        :type: datetime
        """

        self._start_time = start_time

    @property
    def end_time(self):
        """Gets the end_time of this JobDto.  # noqa: E501

        The date and time when the job execution ended or null if the job hasn't ended yet.  # noqa: E501

        :return: The end_time of this JobDto.  # noqa: E501
        :rtype: datetime
        """
        return self._end_time

    @end_time.setter
    def end_time(self, end_time):
        """Sets the end_time of this JobDto.

        The date and time when the job execution ended or null if the job hasn't ended yet.  # noqa: E501

        :param end_time: The end_time of this JobDto.  # noqa: E501
        :type: datetime
        """

        self._end_time = end_time

    @property
    def state(self):
        """Gets the state of this JobDto.  # noqa: E501

        The state in which the job is.  # noqa: E501

        :return: The state of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this JobDto.

        The state in which the job is.  # noqa: E501

        :param state: The state of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["Pending", "Running", "Stopping", "Terminating", "Faulted", "Successful", "Stopped", "Suspended", "Resumed"]  # noqa: E501
        if (self._configuration.client_side_validation and
                state not in allowed_values):
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"  # noqa: E501
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def job_priority(self):
        """Gets the job_priority of this JobDto.  # noqa: E501

        Execution priority.  # noqa: E501

        :return: The job_priority of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._job_priority

    @job_priority.setter
    def job_priority(self, job_priority):
        """Sets the job_priority of this JobDto.

        Execution priority.  # noqa: E501

        :param job_priority: The job_priority of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["Low", "Normal", "High"]  # noqa: E501
        if (self._configuration.client_side_validation and
                job_priority not in allowed_values):
            raise ValueError(
                "Invalid value for `job_priority` ({0}), must be one of {1}"  # noqa: E501
                .format(job_priority, allowed_values)
            )

        self._job_priority = job_priority

    @property
    def specific_priority_value(self):
        """Gets the specific_priority_value of this JobDto.  # noqa: E501

        Value for more granular control over execution priority.  # noqa: E501

        :return: The specific_priority_value of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._specific_priority_value

    @specific_priority_value.setter
    def specific_priority_value(self, specific_priority_value):
        """Sets the specific_priority_value of this JobDto.

        Value for more granular control over execution priority.  # noqa: E501

        :param specific_priority_value: The specific_priority_value of this JobDto.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                specific_priority_value is not None and specific_priority_value > 100):  # noqa: E501
            raise ValueError("Invalid value for `specific_priority_value`, must be a value less than or equal to `100`")  # noqa: E501
        if (self._configuration.client_side_validation and
                specific_priority_value is not None and specific_priority_value < 1):  # noqa: E501
            raise ValueError("Invalid value for `specific_priority_value`, must be a value greater than or equal to `1`")  # noqa: E501

        self._specific_priority_value = specific_priority_value

    @property
    def robot(self):
        """Gets the robot of this JobDto.  # noqa: E501


        :return: The robot of this JobDto.  # noqa: E501
        :rtype: SimpleRobotDto
        """
        return self._robot

    @robot.setter
    def robot(self, robot):
        """Sets the robot of this JobDto.


        :param robot: The robot of this JobDto.  # noqa: E501
        :type: SimpleRobotDto
        """

        self._robot = robot

    @property
    def release(self):
        """Gets the release of this JobDto.  # noqa: E501


        :return: The release of this JobDto.  # noqa: E501
        :rtype: SimpleReleaseDto
        """
        return self._release

    @release.setter
    def release(self, release):
        """Sets the release of this JobDto.


        :param release: The release of this JobDto.  # noqa: E501
        :type: SimpleReleaseDto
        """

        self._release = release

    @property
    def resource_overwrites(self):
        """Gets the resource_overwrites of this JobDto.  # noqa: E501

        Job overwrites  # noqa: E501

        :return: The resource_overwrites of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._resource_overwrites

    @resource_overwrites.setter
    def resource_overwrites(self, resource_overwrites):
        """Sets the resource_overwrites of this JobDto.

        Job overwrites  # noqa: E501

        :param resource_overwrites: The resource_overwrites of this JobDto.  # noqa: E501
        :type: str
        """

        self._resource_overwrites = resource_overwrites

    @property
    def source(self):
        """Gets the source of this JobDto.  # noqa: E501

        The Source name of the job.  # noqa: E501

        :return: The source of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._source

    @source.setter
    def source(self, source):
        """Sets the source of this JobDto.

        The Source name of the job.  # noqa: E501

        :param source: The source of this JobDto.  # noqa: E501
        :type: str
        """

        self._source = source

    @property
    def source_type(self):
        """Gets the source_type of this JobDto.  # noqa: E501

        The Source type of the job.  # noqa: E501

        :return: The source_type of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._source_type

    @source_type.setter
    def source_type(self, source_type):
        """Sets the source_type of this JobDto.

        The Source type of the job.  # noqa: E501

        :param source_type: The source_type of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["Manual", "Schedule", "Agent", "Queue", "StudioWeb", "IntegrationTrigger", "StudioDesktop", "AutomationOpsPipelines", "Apps", "SAP", "HttpTrigger", "HttpTriggerCallback", "RobotAPI", "CommandLine", "RobotNetAPI"]  # noqa: E501
        if (self._configuration.client_side_validation and
                source_type not in allowed_values):
            raise ValueError(
                "Invalid value for `source_type` ({0}), must be one of {1}"  # noqa: E501
                .format(source_type, allowed_values)
            )

        self._source_type = source_type

    @property
    def batch_execution_key(self):
        """Gets the batch_execution_key of this JobDto.  # noqa: E501

        The unique identifier grouping multiple jobs. It is usually generated when the job is created by a schedule.  # noqa: E501

        :return: The batch_execution_key of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._batch_execution_key

    @batch_execution_key.setter
    def batch_execution_key(self, batch_execution_key):
        """Sets the batch_execution_key of this JobDto.

        The unique identifier grouping multiple jobs. It is usually generated when the job is created by a schedule.  # noqa: E501

        :param batch_execution_key: The batch_execution_key of this JobDto.  # noqa: E501
        :type: str
        """

        self._batch_execution_key = batch_execution_key

    @property
    def info(self):
        """Gets the info of this JobDto.  # noqa: E501

        Additional information about the current job.  # noqa: E501

        :return: The info of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._info

    @info.setter
    def info(self, info):
        """Sets the info of this JobDto.

        Additional information about the current job.  # noqa: E501

        :param info: The info of this JobDto.  # noqa: E501
        :type: str
        """

        self._info = info

    @property
    def creation_time(self):
        """Gets the creation_time of this JobDto.  # noqa: E501

        The date and time when the job was created.  # noqa: E501

        :return: The creation_time of this JobDto.  # noqa: E501
        :rtype: datetime
        """
        return self._creation_time

    @creation_time.setter
    def creation_time(self, creation_time):
        """Sets the creation_time of this JobDto.

        The date and time when the job was created.  # noqa: E501

        :param creation_time: The creation_time of this JobDto.  # noqa: E501
        :type: datetime
        """

        self._creation_time = creation_time

    @property
    def starting_schedule_id(self):
        """Gets the starting_schedule_id of this JobDto.  # noqa: E501

        The Id of the schedule that started the job, or null if the job was started by the user.  # noqa: E501

        :return: The starting_schedule_id of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._starting_schedule_id

    @starting_schedule_id.setter
    def starting_schedule_id(self, starting_schedule_id):
        """Sets the starting_schedule_id of this JobDto.

        The Id of the schedule that started the job, or null if the job was started by the user.  # noqa: E501

        :param starting_schedule_id: The starting_schedule_id of this JobDto.  # noqa: E501
        :type: int
        """

        self._starting_schedule_id = starting_schedule_id

    @property
    def release_name(self):
        """Gets the release_name of this JobDto.  # noqa: E501

        The name of the release associated with the current name.  # noqa: E501

        :return: The release_name of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._release_name

    @release_name.setter
    def release_name(self, release_name):
        """Sets the release_name of this JobDto.

        The name of the release associated with the current name.  # noqa: E501

        :param release_name: The release_name of this JobDto.  # noqa: E501
        :type: str
        """

        self._release_name = release_name

    @property
    def type(self):
        """Gets the type of this JobDto.  # noqa: E501

        The type of the job, Attended if started via the robot, Unattended otherwise  # noqa: E501

        :return: The type of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this JobDto.

        The type of the job, Attended if started via the robot, Unattended otherwise  # noqa: E501

        :param type: The type of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["Unattended", "Attended", "ServerlessGeneric"]  # noqa: E501
        if (self._configuration.client_side_validation and
                type not in allowed_values):
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def input_arguments(self):
        """Gets the input_arguments of this JobDto.  # noqa: E501

        Input parameters in JSON format to be passed to job execution  # noqa: E501

        :return: The input_arguments of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._input_arguments

    @input_arguments.setter
    def input_arguments(self, input_arguments):
        """Sets the input_arguments of this JobDto.

        Input parameters in JSON format to be passed to job execution  # noqa: E501

        :param input_arguments: The input_arguments of this JobDto.  # noqa: E501
        :type: str
        """

        self._input_arguments = input_arguments

    @property
    def output_arguments(self):
        """Gets the output_arguments of this JobDto.  # noqa: E501

        Output parameters in JSON format resulted from job execution  # noqa: E501

        :return: The output_arguments of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._output_arguments

    @output_arguments.setter
    def output_arguments(self, output_arguments):
        """Sets the output_arguments of this JobDto.

        Output parameters in JSON format resulted from job execution  # noqa: E501

        :param output_arguments: The output_arguments of this JobDto.  # noqa: E501
        :type: str
        """

        self._output_arguments = output_arguments

    @property
    def host_machine_name(self):
        """Gets the host_machine_name of this JobDto.  # noqa: E501

        The name of the machine where the Robot run the job.  # noqa: E501

        :return: The host_machine_name of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._host_machine_name

    @host_machine_name.setter
    def host_machine_name(self, host_machine_name):
        """Sets the host_machine_name of this JobDto.

        The name of the machine where the Robot run the job.  # noqa: E501

        :param host_machine_name: The host_machine_name of this JobDto.  # noqa: E501
        :type: str
        """

        self._host_machine_name = host_machine_name

    @property
    def has_media_recorded(self):
        """Gets the has_media_recorded of this JobDto.  # noqa: E501

        DEPRECATED. True if any execution media has been recorded for this job, false otherwise.  # noqa: E501

        :return: The has_media_recorded of this JobDto.  # noqa: E501
        :rtype: bool
        """
        return self._has_media_recorded

    @has_media_recorded.setter
    def has_media_recorded(self, has_media_recorded):
        """Sets the has_media_recorded of this JobDto.

        DEPRECATED. True if any execution media has been recorded for this job, false otherwise.  # noqa: E501

        :param has_media_recorded: The has_media_recorded of this JobDto.  # noqa: E501
        :type: bool
        """

        self._has_media_recorded = has_media_recorded

    @property
    def has_video_recorded(self):
        """Gets the has_video_recorded of this JobDto.  # noqa: E501

        DEPRECATED. True if any execution video has been recorded for this job, false otherwise.  # noqa: E501

        :return: The has_video_recorded of this JobDto.  # noqa: E501
        :rtype: bool
        """
        return self._has_video_recorded

    @has_video_recorded.setter
    def has_video_recorded(self, has_video_recorded):
        """Sets the has_video_recorded of this JobDto.

        DEPRECATED. True if any execution video has been recorded for this job, false otherwise.  # noqa: E501

        :param has_video_recorded: The has_video_recorded of this JobDto.  # noqa: E501
        :type: bool
        """

        self._has_video_recorded = has_video_recorded

    @property
    def persistence_id(self):
        """Gets the persistence_id of this JobDto.  # noqa: E501

        The persistence instance id for a suspended job  # noqa: E501

        :return: The persistence_id of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._persistence_id

    @persistence_id.setter
    def persistence_id(self, persistence_id):
        """Sets the persistence_id of this JobDto.

        The persistence instance id for a suspended job  # noqa: E501

        :param persistence_id: The persistence_id of this JobDto.  # noqa: E501
        :type: str
        """

        self._persistence_id = persistence_id

    @property
    def resume_version(self):
        """Gets the resume_version of this JobDto.  # noqa: E501

        Distinguishes between multiple job suspend/resume cycles  # noqa: E501

        :return: The resume_version of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._resume_version

    @resume_version.setter
    def resume_version(self, resume_version):
        """Sets the resume_version of this JobDto.

        Distinguishes between multiple job suspend/resume cycles  # noqa: E501

        :param resume_version: The resume_version of this JobDto.  # noqa: E501
        :type: int
        """

        self._resume_version = resume_version

    @property
    def stop_strategy(self):
        """Gets the stop_strategy of this JobDto.  # noqa: E501


        :return: The stop_strategy of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._stop_strategy

    @stop_strategy.setter
    def stop_strategy(self, stop_strategy):
        """Sets the stop_strategy of this JobDto.


        :param stop_strategy: The stop_strategy of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["SoftStop", "Kill"]  # noqa: E501
        if (self._configuration.client_side_validation and
                stop_strategy not in allowed_values):
            raise ValueError(
                "Invalid value for `stop_strategy` ({0}), must be one of {1}"  # noqa: E501
                .format(stop_strategy, allowed_values)
            )

        self._stop_strategy = stop_strategy

    @property
    def runtime_type(self):
        """Gets the runtime_type of this JobDto.  # noqa: E501

        The runtime type of the robot which can pick up the job  # noqa: E501

        :return: The runtime_type of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._runtime_type

    @runtime_type.setter
    def runtime_type(self, runtime_type):
        """Sets the runtime_type of this JobDto.

        The runtime type of the robot which can pick up the job  # noqa: E501

        :param runtime_type: The runtime_type of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["NonProduction", "Attended", "Unattended", "Development", "Studio", "RpaDeveloper", "StudioX", "CitizenDeveloper", "Headless", "StudioPro", "RpaDeveloperPro", "TestAutomation", "AutomationCloud", "Serverless", "AutomationKit", "ServerlessTestAutomation", "AutomationCloudTestAutomation", "AttendedStudioWeb"]  # noqa: E501
        if (self._configuration.client_side_validation and
                runtime_type not in allowed_values):
            raise ValueError(
                "Invalid value for `runtime_type` ({0}), must be one of {1}"  # noqa: E501
                .format(runtime_type, allowed_values)
            )

        self._runtime_type = runtime_type

    @property
    def requires_user_interaction(self):
        """Gets the requires_user_interaction of this JobDto.  # noqa: E501


        :return: The requires_user_interaction of this JobDto.  # noqa: E501
        :rtype: bool
        """
        return self._requires_user_interaction

    @requires_user_interaction.setter
    def requires_user_interaction(self, requires_user_interaction):
        """Sets the requires_user_interaction of this JobDto.


        :param requires_user_interaction: The requires_user_interaction of this JobDto.  # noqa: E501
        :type: bool
        """

        self._requires_user_interaction = requires_user_interaction

    @property
    def release_version_id(self):
        """Gets the release_version_id of this JobDto.  # noqa: E501


        :return: The release_version_id of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._release_version_id

    @release_version_id.setter
    def release_version_id(self, release_version_id):
        """Sets the release_version_id of this JobDto.


        :param release_version_id: The release_version_id of this JobDto.  # noqa: E501
        :type: int
        """

        self._release_version_id = release_version_id

    @property
    def entry_point_path(self):
        """Gets the entry_point_path of this JobDto.  # noqa: E501

        Path to the entry point workflow (XAML) that will be executed by the robot  # noqa: E501

        :return: The entry_point_path of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._entry_point_path

    @entry_point_path.setter
    def entry_point_path(self, entry_point_path):
        """Sets the entry_point_path of this JobDto.

        Path to the entry point workflow (XAML) that will be executed by the robot  # noqa: E501

        :param entry_point_path: The entry_point_path of this JobDto.  # noqa: E501
        :type: str
        """
        if (self._configuration.client_side_validation and
                entry_point_path is not None and len(entry_point_path) > 512):
            raise ValueError("Invalid value for `entry_point_path`, length must be less than or equal to `512`")  # noqa: E501

        self._entry_point_path = entry_point_path

    @property
    def organization_unit_id(self):
        """Gets the organization_unit_id of this JobDto.  # noqa: E501

        Id of the folder this job is part of.  # noqa: E501

        :return: The organization_unit_id of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._organization_unit_id

    @organization_unit_id.setter
    def organization_unit_id(self, organization_unit_id):
        """Sets the organization_unit_id of this JobDto.

        Id of the folder this job is part of.  # noqa: E501

        :param organization_unit_id: The organization_unit_id of this JobDto.  # noqa: E501
        :type: int
        """

        self._organization_unit_id = organization_unit_id

    @property
    def organization_unit_fully_qualified_name(self):
        """Gets the organization_unit_fully_qualified_name of this JobDto.  # noqa: E501

        Fully qualified name of the folder this job is part of.  # noqa: E501

        :return: The organization_unit_fully_qualified_name of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._organization_unit_fully_qualified_name

    @organization_unit_fully_qualified_name.setter
    def organization_unit_fully_qualified_name(self, organization_unit_fully_qualified_name):
        """Sets the organization_unit_fully_qualified_name of this JobDto.

        Fully qualified name of the folder this job is part of.  # noqa: E501

        :param organization_unit_fully_qualified_name: The organization_unit_fully_qualified_name of this JobDto.  # noqa: E501
        :type: str
        """

        self._organization_unit_fully_qualified_name = organization_unit_fully_qualified_name

    @property
    def reference(self):
        """Gets the reference of this JobDto.  # noqa: E501

        Reference identifier for the job  # noqa: E501

        :return: The reference of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._reference

    @reference.setter
    def reference(self, reference):
        """Sets the reference of this JobDto.

        Reference identifier for the job  # noqa: E501

        :param reference: The reference of this JobDto.  # noqa: E501
        :type: str
        """

        self._reference = reference

    @property
    def process_type(self):
        """Gets the process_type of this JobDto.  # noqa: E501


        :return: The process_type of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._process_type

    @process_type.setter
    def process_type(self, process_type):
        """Sets the process_type of this JobDto.


        :param process_type: The process_type of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["Undefined", "Process", "TestAutomationProcess"]  # noqa: E501
        if (self._configuration.client_side_validation and
                process_type not in allowed_values):
            raise ValueError(
                "Invalid value for `process_type` ({0}), must be one of {1}"  # noqa: E501
                .format(process_type, allowed_values)
            )

        self._process_type = process_type

    @property
    def machine(self):
        """Gets the machine of this JobDto.  # noqa: E501


        :return: The machine of this JobDto.  # noqa: E501
        :rtype: MachineDto
        """
        return self._machine

    @machine.setter
    def machine(self, machine):
        """Sets the machine of this JobDto.


        :param machine: The machine of this JobDto.  # noqa: E501
        :type: MachineDto
        """

        self._machine = machine

    @property
    def profiling_options(self):
        """Gets the profiling_options of this JobDto.  # noqa: E501

        Options to instruct the robot what profiling info to collect (code coverage, CPU / memory utilization, etc)  # noqa: E501

        :return: The profiling_options of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._profiling_options

    @profiling_options.setter
    def profiling_options(self, profiling_options):
        """Sets the profiling_options of this JobDto.

        Options to instruct the robot what profiling info to collect (code coverage, CPU / memory utilization, etc)  # noqa: E501

        :param profiling_options: The profiling_options of this JobDto.  # noqa: E501
        :type: str
        """

        self._profiling_options = profiling_options

    @property
    def resume_on_same_context(self):
        """Gets the resume_on_same_context of this JobDto.  # noqa: E501

        Flag for honoring initial machine and robot choice upon resumption of job if suspended. <br />  If set, the job will resume on the same robot-machine pair on which it initially ran.  # noqa: E501

        :return: The resume_on_same_context of this JobDto.  # noqa: E501
        :rtype: bool
        """
        return self._resume_on_same_context

    @resume_on_same_context.setter
    def resume_on_same_context(self, resume_on_same_context):
        """Sets the resume_on_same_context of this JobDto.

        Flag for honoring initial machine and robot choice upon resumption of job if suspended. <br />  If set, the job will resume on the same robot-machine pair on which it initially ran.  # noqa: E501

        :param resume_on_same_context: The resume_on_same_context of this JobDto.  # noqa: E501
        :type: bool
        """

        self._resume_on_same_context = resume_on_same_context

    @property
    def local_system_account(self):
        """Gets the local_system_account of this JobDto.  # noqa: E501

        The account under which the robot executor will run the job  # noqa: E501

        :return: The local_system_account of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._local_system_account

    @local_system_account.setter
    def local_system_account(self, local_system_account):
        """Sets the local_system_account of this JobDto.

        The account under which the robot executor will run the job  # noqa: E501

        :param local_system_account: The local_system_account of this JobDto.  # noqa: E501
        :type: str
        """

        self._local_system_account = local_system_account

    @property
    def orchestrator_user_identity(self):
        """Gets the orchestrator_user_identity of this JobDto.  # noqa: E501

        The orchestrator identity used to make API calls  # noqa: E501

        :return: The orchestrator_user_identity of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._orchestrator_user_identity

    @orchestrator_user_identity.setter
    def orchestrator_user_identity(self, orchestrator_user_identity):
        """Sets the orchestrator_user_identity of this JobDto.

        The orchestrator identity used to make API calls  # noqa: E501

        :param orchestrator_user_identity: The orchestrator_user_identity of this JobDto.  # noqa: E501
        :type: str
        """

        self._orchestrator_user_identity = orchestrator_user_identity

    @property
    def remote_control_access(self):
        """Gets the remote_control_access of this JobDto.  # noqa: E501


        :return: The remote_control_access of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._remote_control_access

    @remote_control_access.setter
    def remote_control_access(self, remote_control_access):
        """Sets the remote_control_access of this JobDto.


        :param remote_control_access: The remote_control_access of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["None", "ReadOnly", "Full"]  # noqa: E501
        if (self._configuration.client_side_validation and
                remote_control_access not in allowed_values):
            raise ValueError(
                "Invalid value for `remote_control_access` ({0}), must be one of {1}"  # noqa: E501
                .format(remote_control_access, allowed_values)
            )

        self._remote_control_access = remote_control_access

    @property
    def starting_trigger_id(self):
        """Gets the starting_trigger_id of this JobDto.  # noqa: E501

        Starting Trigger Id. Can be ApiTriggerId or HttpTriggerId.  # noqa: E501

        :return: The starting_trigger_id of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._starting_trigger_id

    @starting_trigger_id.setter
    def starting_trigger_id(self, starting_trigger_id):
        """Sets the starting_trigger_id of this JobDto.

        Starting Trigger Id. Can be ApiTriggerId or HttpTriggerId.  # noqa: E501

        :param starting_trigger_id: The starting_trigger_id of this JobDto.  # noqa: E501
        :type: str
        """

        self._starting_trigger_id = starting_trigger_id

    @property
    def max_expected_running_time_seconds(self):
        """Gets the max_expected_running_time_seconds of this JobDto.  # noqa: E501

        Expected running time in seconds  # noqa: E501

        :return: The max_expected_running_time_seconds of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._max_expected_running_time_seconds

    @max_expected_running_time_seconds.setter
    def max_expected_running_time_seconds(self, max_expected_running_time_seconds):
        """Sets the max_expected_running_time_seconds of this JobDto.

        Expected running time in seconds  # noqa: E501

        :param max_expected_running_time_seconds: The max_expected_running_time_seconds of this JobDto.  # noqa: E501
        :type: int
        """

        self._max_expected_running_time_seconds = max_expected_running_time_seconds

    @property
    def serverless_job_type(self):
        """Gets the serverless_job_type of this JobDto.  # noqa: E501

        The type of the serverless job, RobotJob or Generic  # noqa: E501

        :return: The serverless_job_type of this JobDto.  # noqa: E501
        :rtype: str
        """
        return self._serverless_job_type

    @serverless_job_type.setter
    def serverless_job_type(self, serverless_job_type):
        """Sets the serverless_job_type of this JobDto.

        The type of the serverless job, RobotJob or Generic  # noqa: E501

        :param serverless_job_type: The serverless_job_type of this JobDto.  # noqa: E501
        :type: str
        """
        allowed_values = ["RobotJob", "StudioWebDesigner"]  # noqa: E501
        if (self._configuration.client_side_validation and
                serverless_job_type not in allowed_values):
            raise ValueError(
                "Invalid value for `serverless_job_type` ({0}), must be one of {1}"  # noqa: E501
                .format(serverless_job_type, allowed_values)
            )

        self._serverless_job_type = serverless_job_type

    @property
    def resume_time(self):
        """Gets the resume_time of this JobDto.  # noqa: E501


        :return: The resume_time of this JobDto.  # noqa: E501
        :rtype: datetime
        """
        return self._resume_time

    @resume_time.setter
    def resume_time(self, resume_time):
        """Sets the resume_time of this JobDto.


        :param resume_time: The resume_time of this JobDto.  # noqa: E501
        :type: datetime
        """

        self._resume_time = resume_time

    @property
    def last_modification_time(self):
        """Gets the last_modification_time of this JobDto.  # noqa: E501


        :return: The last_modification_time of this JobDto.  # noqa: E501
        :rtype: datetime
        """
        return self._last_modification_time

    @last_modification_time.setter
    def last_modification_time(self, last_modification_time):
        """Sets the last_modification_time of this JobDto.


        :param last_modification_time: The last_modification_time of this JobDto.  # noqa: E501
        :type: datetime
        """

        self._last_modification_time = last_modification_time

    @property
    def id(self):
        """Gets the id of this JobDto.  # noqa: E501


        :return: The id of this JobDto.  # noqa: E501
        :rtype: int
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this JobDto.


        :param id: The id of this JobDto.  # noqa: E501
        :type: int
        """

        self._id = id

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(JobDto, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, JobDto):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, JobDto):
            return True

        return self.to_dict() != other.to_dict()
