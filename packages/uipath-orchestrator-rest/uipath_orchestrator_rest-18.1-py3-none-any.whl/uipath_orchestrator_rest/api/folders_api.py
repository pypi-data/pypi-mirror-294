# coding: utf-8

"""
    UiPath.WebApi 18.0

    Orchestrator API  # noqa: E501

    OpenAPI spec version: 18.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from uipath_orchestrator_rest.api_client import ApiClient


class FoldersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def folders_assign_domain_user(self, **kwargs):  # noqa: E501
        """Assigns a directory user or group to a set of folders with an optional set of roles per folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Assigns domain user to any folder or only if user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_assign_domain_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderAssignDomainUserRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_assign_domain_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_assign_domain_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_assign_domain_user_with_http_info(self, **kwargs):  # noqa: E501
        """Assigns a directory user or group to a set of folders with an optional set of roles per folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Assigns domain user to any folder or only if user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_assign_domain_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderAssignDomainUserRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_assign_domain_user" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.AssignDomainUser', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_assign_machines(self, **kwargs):  # noqa: E501
        """Assigns one or more machines to a set of folders.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Assigns machines to any folder or only if user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_assign_machines(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderAssignMachinesRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_assign_machines_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_assign_machines_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_assign_machines_with_http_info(self, **kwargs):  # noqa: E501
        """Assigns one or more machines to a set of folders.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Assigns machines to any folder or only if user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_assign_machines_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderAssignMachinesRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_assign_machines" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.AssignMachines', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_assign_users(self, **kwargs):  # noqa: E501
        """Assigns one or more users to a set of folders with an optional set of roles per folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Assigns users to any folder or if the user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_assign_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderAssignUsersRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_assign_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_assign_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_assign_users_with_http_info(self, **kwargs):  # noqa: E501
        """Assigns one or more users to a set of folders with an optional set of roles per folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Assigns users to any folder or if the user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_assign_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderAssignUsersRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_assign_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.AssignUsers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_delete_by_id(self, key, **kwargs):  # noqa: E501
        """Deletes a folder. Succeeds only if no entities or user associations  exist in this folder or any of its descendants.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Delete or SubFolders.Delete - Deletes any folder or only if user has SubFolders.Delete permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_delete_by_id(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_delete_by_id_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_delete_by_id_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def folders_delete_by_id_with_http_info(self, key, **kwargs):  # noqa: E501
        """Deletes a folder. Succeeds only if no entities or user associations  exist in this folder or any of its descendants.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Delete or SubFolders.Delete - Deletes any folder or only if user has SubFolders.Delete permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_delete_by_id_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_delete_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_delete_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders({key})', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_delete_by_key(self, **kwargs):  # noqa: E501
        """Deletes a folder. Succeeds only if no entities or user associations  exist in this folder or any of its descendants.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Delete or SubFolders.Delete - Deletes any folder or only if user has SubFolders.Delete permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_delete_by_key(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_delete_by_key_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_delete_by_key_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_delete_by_key_with_http_info(self, **kwargs):  # noqa: E501
        """Deletes a folder. Succeeds only if no entities or user associations  exist in this folder or any of its descendants.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Delete or SubFolders.Delete - Deletes any folder or only if user has SubFolders.Delete permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_delete_by_key_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_delete_by_key" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Folders/DeleteByKey', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get(self, **kwargs):  # noqa: E501
        """Gets folders.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets all folders or only the folders where user has SubFolders.View permission).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_get_with_http_info(self, **kwargs):  # noqa: E501
        """Gets folders.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets all folders or only the folders where user has SubFolders.View permission).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['expand', 'filter', 'select', 'orderby', 'top', 'skip', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'count' in params:
            query_params.append(('$count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ODataValueOfIEnumerableOfFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_all_roles_for_user_by_username_and_skip_and_take(self, username, skip, take, **kwargs):  # noqa: E501
        """Returns a page of the user-folder assignments for the input user, including the roles for each folder.  The response also includes the folders assigned to the directory groups of the user.  The distinction between the folders assigned directly to the user and the ones assigned to one of his groups  can be made via the User field of the response.  LIMITATION: If URI parameters contain special characters (eg. \\, /), use instead api/FoldersNavigation/GetAllRolesForUser endpoint.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets roles from all folders or only from folders where user has SubFolders.View permission).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_all_roles_for_user_by_username_and_skip_and_take(username, skip, take, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: User name (required)
        :param int skip:  (required)
        :param int take:  (required)
        :param str type: 
        :param str search_text: 
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str select: Limits the properties returned in the result.
        :return: UserRoleAssignmentsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_all_roles_for_user_by_username_and_skip_and_take_with_http_info(username, skip, take, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_all_roles_for_user_by_username_and_skip_and_take_with_http_info(username, skip, take, **kwargs)  # noqa: E501
            return data

    def folders_get_all_roles_for_user_by_username_and_skip_and_take_with_http_info(self, username, skip, take, **kwargs):  # noqa: E501
        """Returns a page of the user-folder assignments for the input user, including the roles for each folder.  The response also includes the folders assigned to the directory groups of the user.  The distinction between the folders assigned directly to the user and the ones assigned to one of his groups  can be made via the User field of the response.  LIMITATION: If URI parameters contain special characters (eg. \\, /), use instead api/FoldersNavigation/GetAllRolesForUser endpoint.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets roles from all folders or only from folders where user has SubFolders.View permission).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_all_roles_for_user_by_username_and_skip_and_take_with_http_info(username, skip, take, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: User name (required)
        :param int skip:  (required)
        :param int take:  (required)
        :param str type: 
        :param str search_text: 
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str select: Limits the properties returned in the result.
        :return: UserRoleAssignmentsDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'skip', 'take', 'type', 'search_text', 'expand', 'select']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_all_roles_for_user_by_username_and_skip_and_take" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in params or
                                                       params['username'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `username` when calling `folders_get_all_roles_for_user_by_username_and_skip_and_take`")  # noqa: E501
        # verify the required parameter 'skip' is set
        if self.api_client.client_side_validation and ('skip' not in params or
                                                       params['skip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `skip` when calling `folders_get_all_roles_for_user_by_username_and_skip_and_take`")  # noqa: E501
        # verify the required parameter 'take' is set
        if self.api_client.client_side_validation and ('take' not in params or
                                                       params['take'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `take` when calling `folders_get_all_roles_for_user_by_username_and_skip_and_take`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']  # noqa: E501
        if 'skip' in params:
            path_params['skip'] = params['skip']  # noqa: E501
        if 'take' in params:
            path_params['take'] = params['take']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'search_text' in params:
            query_params.append(('searchText', params['search_text']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.GetAllRolesForUser(username={username},skip={skip},take={take})', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserRoleAssignmentsDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_by_id(self, key, **kwargs):  # noqa: E501
        """Gets a single folder, based on its Id.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets any folder or only the folder if user has SubFolders.View permission on it or the user is assigned to the folder.).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_by_id(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str select: Limits the properties returned in the result.
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_by_id_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_by_id_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def folders_get_by_id_with_http_info(self, key, **kwargs):  # noqa: E501
        """Gets a single folder, based on its Id.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets any folder or only the folder if user has SubFolders.View permission on it or the user is assigned to the folder.).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_by_id_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str select: Limits the properties returned in the result.
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'expand', 'select']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_get_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders({key})', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_by_key_by_identifier(self, identifier, **kwargs):  # noqa: E501
        """Gets a single folder, based on its Key.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets any folder or only the folder if user has SubFolders.View permission on it or the user is assigned to the folder.).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_by_key_by_identifier(identifier, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str identifier:  (required)
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_by_key_by_identifier_with_http_info(identifier, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_by_key_by_identifier_with_http_info(identifier, **kwargs)  # noqa: E501
            return data

    def folders_get_by_key_by_identifier_with_http_info(self, identifier, **kwargs):  # noqa: E501
        """Gets a single folder, based on its Key.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets any folder or only the folder if user has SubFolders.View permission on it or the user is assigned to the folder.).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_by_key_by_identifier_with_http_info(identifier, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str identifier:  (required)
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['identifier', 'expand', 'filter', 'select', 'orderby', 'top', 'skip', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_by_key_by_identifier" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'identifier' is set
        if self.api_client.client_side_validation and ('identifier' not in params or
                                                       params['identifier'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `identifier` when calling `folders_get_by_key_by_identifier`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identifier' in params:
            path_params['identifier'] = params['identifier']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'count' in params:
            query_params.append(('$count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.GetByKey(identifier={identifier})', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_machines_for_folder_by_key(self, key, **kwargs):  # noqa: E501
        """Returns the machines assigned to a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets machines for any folder or only if user has SubFolders.View permission on folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_machines_for_folder_by_key(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfMachineFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_machines_for_folder_by_key_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_machines_for_folder_by_key_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def folders_get_machines_for_folder_by_key_with_http_info(self, key, **kwargs):  # noqa: E501
        """Returns the machines assigned to a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets machines for any folder or only if user has SubFolders.View permission on folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_machines_for_folder_by_key_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfMachineFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'expand', 'filter', 'select', 'orderby', 'top', 'skip', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_machines_for_folder_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_get_machines_for_folder_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'count' in params:
            query_params.append(('$count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.GetMachinesForFolder(key={key})', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ODataValueOfIEnumerableOfMachineFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_move_folder_machines_changes(self, **kwargs):  # noqa: E501
        """Gets the machine changes when moving a folder  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (SubFolders.Delete - Deletes folder only if user has SubFolders.Delete permission on it) and (Units.Create or SubFolders.Create - Creates root or subfolder or only subfolder if user has SubFolders.Create permission on parent) and (Units.Edit or SubFolders.Edit - Edits any folder or only if user has SubFolders.Edit permission on it).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_move_folder_machines_changes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int folder_id: Id of the folder to be moved
        :param int target_parent_id: Id of the target parent
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfMoveFolderMachineChange
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_move_folder_machines_changes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_move_folder_machines_changes_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_get_move_folder_machines_changes_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the machine changes when moving a folder  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (SubFolders.Delete - Deletes folder only if user has SubFolders.Delete permission on it) and (Units.Create or SubFolders.Create - Creates root or subfolder or only subfolder if user has SubFolders.Create permission on parent) and (Units.Edit or SubFolders.Edit - Edits any folder or only if user has SubFolders.Edit permission on it).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_move_folder_machines_changes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int folder_id: Id of the folder to be moved
        :param int target_parent_id: Id of the target parent
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfMoveFolderMachineChange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'target_parent_id', 'expand', 'filter', 'select', 'orderby', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_move_folder_machines_changes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'folder_id' in params:
            query_params.append(('folderId', params['folder_id']))  # noqa: E501
        if 'target_parent_id' in params:
            query_params.append(('targetParentId', params['target_parent_id']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501
        if 'count' in params:
            query_params.append(('$count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.GetMoveFolderMachinesChanges', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ODataValueOfIEnumerableOfMoveFolderMachineChange',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_subfolders_with_assigned_machine(self, **kwargs):  # noqa: E501
        """Gets direct machine assignments for all subfolders of the specific folder  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets the subfolders in which the machines is directly assigned for any folder or for subfolders only).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_subfolders_with_assigned_machine(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int root_folder_id: 
        :param int machine_id: 
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_subfolders_with_assigned_machine_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_subfolders_with_assigned_machine_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_get_subfolders_with_assigned_machine_with_http_info(self, **kwargs):  # noqa: E501
        """Gets direct machine assignments for all subfolders of the specific folder  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View - Gets the subfolders in which the machines is directly assigned for any folder or for subfolders only).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_subfolders_with_assigned_machine_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int root_folder_id: 
        :param int machine_id: 
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfFolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['root_folder_id', 'machine_id', 'expand', 'filter', 'select', 'orderby', 'top', 'skip', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_subfolders_with_assigned_machine" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'root_folder_id' in params:
            query_params.append(('rootFolderId', params['root_folder_id']))  # noqa: E501
        if 'machine_id' in params:
            query_params.append(('machineId', params['machine_id']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'count' in params:
            query_params.append(('$count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.GetSubfoldersWithAssignedMachine', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ODataValueOfIEnumerableOfFolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_get_users_for_folder_by_key_and_includeinherited(self, key, include_inherited, **kwargs):  # noqa: E501
        """Returns the users who have access to a folder and optionally the fine-grained roles each one  has on that folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View or Assets.Create or Assets.Edit - Gets users for any folder or if the user has SubFolders.View/Assets.Create/Assets.Edit permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_users_for_folder_by_key_and_includeinherited(key, include_inherited, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param bool include_inherited: If true, the response will include users inherited from ancestors (required)
        :param bool include_alerts_enabled: If true, the response will include alert preferences for each user
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfUserRolesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_get_users_for_folder_by_key_and_includeinherited_with_http_info(key, include_inherited, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_get_users_for_folder_by_key_and_includeinherited_with_http_info(key, include_inherited, **kwargs)  # noqa: E501
            return data

    def folders_get_users_for_folder_by_key_and_includeinherited_with_http_info(self, key, include_inherited, **kwargs):  # noqa: E501
        """Returns the users who have access to a folder and optionally the fine-grained roles each one  has on that folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Read.  Required permissions: (Units.View or SubFolders.View or Assets.Create or Assets.Edit - Gets users for any folder or if the user has SubFolders.View/Assets.Create/Assets.Edit permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_get_users_for_folder_by_key_and_includeinherited_with_http_info(key, include_inherited, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param bool include_inherited: If true, the response will include users inherited from ancestors (required)
        :param bool include_alerts_enabled: If true, the response will include alert preferences for each user
        :param str expand: Indicates the related entities to be represented inline. The maximum depth is 2.
        :param str filter: Restricts the set of items returned. The maximum number of expressions is 100.
        :param str select: Limits the properties returned in the result.
        :param str orderby: Specifies the order in which items are returned. The maximum number of expressions is 5.
        :param int top: Limits the number of items returned from a collection. The maximum value is 1000.
        :param int skip: Excludes the specified number of items of the queried collection from the result.
        :param bool count: Indicates whether the total count of items within a collection are returned in the result.
        :return: ODataValueOfIEnumerableOfUserRolesDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'include_inherited', 'include_alerts_enabled', 'expand', 'filter', 'select', 'orderby', 'top', 'skip', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_get_users_for_folder_by_key_and_includeinherited" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_get_users_for_folder_by_key_and_includeinherited`")  # noqa: E501
        # verify the required parameter 'include_inherited' is set
        if self.api_client.client_side_validation and ('include_inherited' not in params or
                                                       params['include_inherited'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `include_inherited` when calling `folders_get_users_for_folder_by_key_and_includeinherited`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501
        if 'include_inherited' in params:
            path_params['includeInherited'] = params['include_inherited']  # noqa: E501

        query_params = []
        if 'include_alerts_enabled' in params:
            query_params.append(('includeAlertsEnabled', params['include_alerts_enabled']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('$expand', params['expand']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'count' in params:
            query_params.append(('$count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.GetUsersForFolder(key={key},includeInherited={includeInherited})', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ODataValueOfIEnumerableOfUserRolesDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_move_folder_by_folderid(self, folder_id, **kwargs):  # noqa: E501
        """Move a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Delete or SubFolders.Delete - Move any folder or to folder only if user has SubFolders.Delete permission on it) and (Units.Create or SubFolders.Create - Move to any target folder or to folder if user has SubFolders.Create permission on target) and (Units.Edit or SubFolders.Edit - Move to any target folder or to folder if user has SubFolders.Edit permission on target).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_move_folder_by_folderid(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int folder_id: Id of the folder to be moved (required)
        :param int target_parent_id: Id of the target parent
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_move_folder_by_folderid_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_move_folder_by_folderid_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def folders_move_folder_by_folderid_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Move a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Delete or SubFolders.Delete - Move any folder or to folder only if user has SubFolders.Delete permission on it) and (Units.Create or SubFolders.Create - Move to any target folder or to folder if user has SubFolders.Create permission on target) and (Units.Edit or SubFolders.Edit - Move to any target folder or to folder if user has SubFolders.Edit permission on target).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_move_folder_by_folderid_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int folder_id: Id of the folder to be moved (required)
        :param int target_parent_id: Id of the target parent
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'target_parent_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_move_folder_by_folderid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in params or
                                                       params['folder_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `folder_id` when calling `folders_move_folder_by_folderid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []
        if 'target_parent_id' in params:
            query_params.append(('targetParentId', params['target_parent_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders({folderId})/UiPath.Server.Configuration.OData.MoveFolder', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_patch_name_description(self, **kwargs):  # noqa: E501
        """Edits a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Edits any folder or edits only if user has SubFolders.Edit permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_patch_name_description(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderUpdateNameDescriptionRequest body: 
        :param str key: 
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_patch_name_description_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_patch_name_description_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_patch_name_description_with_http_info(self, **kwargs):  # noqa: E501
        """Edits a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Edits any folder or edits only if user has SubFolders.Edit permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_patch_name_description_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderUpdateNameDescriptionRequest body: 
        :param str key: 
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_patch_name_description" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Folders/PatchNameDescription', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_post(self, **kwargs):  # noqa: E501
        """Creates a new folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Create or SubFolders.Create - Creates root or subfolder or only subfolder if user has SubFolders.Create permission on parent).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderDto body: 
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_post_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a new folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Create or SubFolders.Create - Creates root or subfolder or only subfolder if user has SubFolders.Create permission on parent).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderDto body: 
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_put_by_id(self, key, **kwargs):  # noqa: E501
        """Edits a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Edits any folder or edits only if user has SubFolders.Edit permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_put_by_id(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param FolderDto body: 
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_put_by_id_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_put_by_id_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def folders_put_by_id_with_http_info(self, key, **kwargs):  # noqa: E501
        """Edits a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Edits any folder or edits only if user has SubFolders.Edit permission on the provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_put_by_id_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param FolderDto body: 
        :return: FolderDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_put_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_put_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders({key})', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_remove_machines_from_folder_by_id(self, key, **kwargs):  # noqa: E501
        """Remove user assignment from a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Removes machines from any folder or only if caller has SubFolders.Edit permission the folder provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_remove_machines_from_folder_by_id(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param RemoveMachinesFromFolderRequest body: The Ids of the machines to remove from the folder
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_remove_machines_from_folder_by_id_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_remove_machines_from_folder_by_id_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def folders_remove_machines_from_folder_by_id_with_http_info(self, key, **kwargs):  # noqa: E501
        """Remove user assignment from a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Removes machines from any folder or only if caller has SubFolders.Edit permission the folder provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_remove_machines_from_folder_by_id_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param RemoveMachinesFromFolderRequest body: The Ids of the machines to remove from the folder
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_remove_machines_from_folder_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_remove_machines_from_folder_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders({key})/UiPath.Server.Configuration.OData.RemoveMachinesFromFolder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_remove_user_from_folder_by_id(self, key, **kwargs):  # noqa: E501
        """Remove user assignment from a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Remove user from any folder or only if caller has SubFolders.Edit permission on provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_remove_user_from_folder_by_id(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param RemoveUserFromFolderRequest body: userId - The Id of the user to remove from the folder
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_remove_user_from_folder_by_id_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.folders_remove_user_from_folder_by_id_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def folders_remove_user_from_folder_by_id_with_http_info(self, key, **kwargs):  # noqa: E501
        """Remove user assignment from a folder.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Remove user from any folder or only if caller has SubFolders.Edit permission on provided folder).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_remove_user_from_folder_by_id_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int key:  (required)
        :param RemoveUserFromFolderRequest body: userId - The Id of the user to remove from the folder
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_remove_user_from_folder_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `folders_remove_user_from_folder_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders({key})/UiPath.Server.Configuration.OData.RemoveUserFromFolder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_toggle_folder_machine_inherit(self, **kwargs):  # noqa: E501
        """Toggle machine propagation for a folder to all subfolders.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Propagate machine to subfolders only if Units.Edit permission is provided or only if SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_toggle_folder_machine_inherit(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderMachineInheritDto body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_toggle_folder_machine_inherit_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_toggle_folder_machine_inherit_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_toggle_folder_machine_inherit_with_http_info(self, **kwargs):  # noqa: E501
        """Toggle machine propagation for a folder to all subfolders.  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Propagate machine to subfolders only if Units.Edit permission is provided or only if SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_toggle_folder_machine_inherit_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderMachineInheritDto body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_toggle_folder_machine_inherit" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.ToggleFolderMachineInherit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def folders_update_machines_to_folder_associations(self, **kwargs):  # noqa: E501
        """Add and remove machine associations to a folder  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Update machines to any folder associations or only if user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_update_machines_to_folder_associations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateMachinesToFolderAssociationsRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.folders_update_machines_to_folder_associations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.folders_update_machines_to_folder_associations_with_http_info(**kwargs)  # noqa: E501
            return data

    def folders_update_machines_to_folder_associations_with_http_info(self, **kwargs):  # noqa: E501
        """Add and remove machine associations to a folder  # noqa: E501

        OAuth required scopes: OR.Folders or OR.Folders.Write.  Required permissions: (Units.Edit or SubFolders.Edit - Update machines to any folder associations or only if user has SubFolders.Edit permission on all folders provided).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.folders_update_machines_to_folder_associations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateMachinesToFolderAssociationsRequest body: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method folders_update_machines_to_folder_associations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json-patch+json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2']  # noqa: E501

        return self.api_client.call_api(
            '/odata/Folders/UiPath.Server.Configuration.OData.UpdateMachinesToFolderAssociations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
