import logging
from .protocol.packets import CMD_SUBMIT as CMD_SUBMIT, CMD_UNLINK as CMD_UNLINK, CommonHeader as CommonHeader, HEADER_BASIC as HEADER_BASIC, OP_REP_DEVLIST_HEADER as OP_REP_DEVLIST_HEADER, OP_REP_DEV_INTERFACE as OP_REP_DEV_INTERFACE, OP_REP_DEV_PATH as OP_REP_DEV_PATH, OP_REP_IMPORT as OP_REP_IMPORT, OP_REQ_DEVLIST as OP_REQ_DEVLIST, OP_REQ_IMPORT as OP_REQ_IMPORT, RET_SUBMIT_PREFIX as RET_SUBMIT_PREFIX, RET_UNLINK as RET_UNLINK
from .protocol.urb_packets import ConfigurationDescriptor as ConfigurationDescriptor, DeviceDescriptor as DeviceDescriptor, EndPointDescriptor as EndPointDescriptor, GenericDescriptor as GenericDescriptor, StringDescriptor as StringDescriptor, UrbSetupPacket as UrbSetupPacket
from .protocol.usb_descriptors import DescriptorType as DescriptorType, DeviceInterfaceClass as DeviceInterfaceClass
from .protocol.usbip_defs import BasicCommands as BasicCommands, CDCControl as CDCControl, Direction as Direction, ErrorCodes as ErrorCodes, Status as Status
from .protocol.usbip_protocol import URBCDCRequestType as URBCDCRequestType, URBSetupRequestType as URBSetupRequestType, URBStandardDeviceRequest as URBStandardDeviceRequest, URBTransferFlags as URBTransferFlags
from _typeshed import Incomplete
from dataclasses import dataclass
from serial_usbipclient.socket_wrapper import SocketWrapper as SocketWrapper

LOGGER: logging.Logger
PAYLOAD_TIMEOUT: float

@dataclass
class HardwareID:
    vid: int = ...
    pid: int = ...
    def __eq__(self, other: object) -> bool: ...
    def __init__(self, vid=..., pid=...) -> None: ...

@dataclass
class USB_Endpoint:
    endpoint: EndPointDescriptor | None = ...
    @property
    def number(self) -> int: ...
    def __init__(self, endpoint=...) -> None: ...

class CDCEndpoints:
    control: Incomplete
    input: Incomplete
    output: Incomplete
    def __init__(self) -> None: ...

class USBIPError(Exception):
    detail: Incomplete
    def __init__(self, detail: str) -> None: ...

class USBIPValueError(ValueError): ...
class USBIPServerTimeoutError(USBIPError): ...
class USBIPConnectionError(USBIPError): ...

class USBIPResponseTimeoutError(USBIPError):
    timeout: Incomplete
    request: Incomplete
    size: Incomplete
    def __init__(self, **kwargs) -> None: ...

class USBConnectionLostError(USBIPError):
    USB_DISCONNECT: list[int]
    connection: Incomplete
    def __init__(self, detail: str, connection: USBIP_Connection | SocketWrapper) -> None: ...

class USBAttachError(USBIPError):
    errno: Incomplete
    def __init__(self, detail: str, an_errno: int) -> None: ...

class USBIP_Connection:
    busnum: Incomplete
    devnum: Incomplete
    seqnum: Incomplete
    device: Incomplete
    socket: Incomplete
    def __init__(self, busnum: int = 0, devnum: int = 0, seqnum: int = 0, device: HardwareID | None = None, sock: SocketWrapper | None = None) -> None: ...
    @property
    def delimiter(self) -> bytes: ...
    @delimiter.setter
    def delimiter(self, delimiter: bytes) -> None: ...
    @property
    def endpoint(self) -> CDCEndpoints: ...
    @property
    def devid(self) -> int: ...
    @property
    def device_desc(self) -> DeviceDescriptor | None: ...
    @device_desc.setter
    def device_desc(self, desc: DeviceDescriptor) -> None: ...
    @property
    def logger(self) -> logging.Logger: ...
    @logger.setter
    def logger(self, logger: logging.Logger) -> None: ...
    @property
    def configuration(self) -> ConfigurationDescriptor: ...
    @configuration.setter
    def configuration(self, configuration: ConfigurationDescriptor) -> None: ...
    @property
    def control(self) -> USB_Endpoint: ...
    @property
    def output(self) -> USB_Endpoint: ...
    @property
    def input(self) -> USB_Endpoint: ...
    @property
    def pending_commands(self) -> list[CMD_SUBMIT]: ...
    @property
    def pending_reads(self) -> int: ...
    def sendall(self, data: bytes) -> None: ...
    def send_command(self, command: CMD_SUBMIT) -> int: ...
    def send_unlink(self, command: CMD_UNLINK) -> bool: ...
    @staticmethod
    def readall(size: int, usb: USBIP_Connection | SocketWrapper, timeout: float = ...) -> bytes: ...
    def wait_for_unlink(self) -> RET_UNLINK | None: ...
    def wait_for_response(self, header_data: bytes | None = None) -> bool: ...
    def response_data(self, timeout: float = ..., size: int = 0) -> bytes: ...

class USBIPClient:
    USBIP_TIMEOUT: float
    READ_BUFFER_SIZE: int
    URB_QUEUE_MIN: int
    URB_QUEUE_MAX: int
    SERVER_CONNECT_TIMEOUT: float
    def __init__(self, remote: tuple[str, int], command_timeout: float = ..., socket_class: type = ...) -> None: ...
    @property
    def command_timeout(self) -> float: ...
    def disconnect_server(self) -> None: ...
    def connect_server(self) -> None: ...
    def set_tcp_nodelay(self) -> None: ...
    @property
    def usbipd(self) -> SocketWrapper | None: ...
    def create_connection(self, device: HardwareID, attached: OP_REP_IMPORT) -> USBIP_Connection: ...
    @staticmethod
    def readall(size: int, usb: USBIP_Connection | SocketWrapper, timeout: float = ...) -> bytes: ...
    def list_published(self) -> OP_REP_DEVLIST_HEADER: ...
    def import_device(self, busid: bytes) -> OP_REP_IMPORT: ...
    def send_setup(self, setup: UrbSetupPacket, usb: USBIP_Connection, data: bytes | None = None) -> None: ...
    def request_descriptor(self, setup: UrbSetupPacket, usb: USBIP_Connection) -> DeviceDescriptor | ConfigurationDescriptor | StringDescriptor: ...
    def set_line_coding(self, setup: UrbSetupPacket, data: bytes, usb: USBIP_Connection) -> None: ...
    def set_line_control_state(self, usb: USBIP_Connection) -> None: ...
    def set_configuration(self, setup: UrbSetupPacket, usb: USBIP_Connection) -> None: ...
    def setup(self, usb: USBIP_Connection): ...
    def attach(self, devices: list[HardwareID], published: OP_REP_DEVLIST_HEADER | None = None) -> None: ...
    def get_connection(self, device: HardwareID) -> list[USBIP_Connection]: ...
    def queue_urbs(self, usb: USBIP_Connection): ...
    def send(self, usb: USBIP_Connection, data: bytes | str) -> int: ...
    @staticmethod
    def read(usb: USBIP_Connection, size: int) -> None: ...
    @staticmethod
    def readline(usb: USBIP_Connection) -> str: ...
    def shutdown_connection(self, usb: USBIP_Connection) -> None: ...
    def shutdown(self) -> None: ...
    def is_device(self, usb: USBIP_Connection, path: OP_REP_DEV_PATH) -> bool: ...
    def restore_connection(self, lost_usb: USBIP_Connection) -> USBIP_Connection | None: ...
