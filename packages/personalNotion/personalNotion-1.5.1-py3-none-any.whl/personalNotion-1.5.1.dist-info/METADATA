Metadata-Version: 2.1
Name: personalNotion
Version: 1.5.1
Summary: All functions that assist in standardising development approaches.
Home-page: https://github.com/yourusername/your-repo
Author: Marcus
Author-email: marcusongkiansiong@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.6
Description-Content-Type: text/markdown
Requires-Dist: custom-development-standardisation >=1.1.2
Requires-Dist: log-data >=1.2.0
Requires-Dist: python-dotenv >=1.0.1
Requires-Dist: Requests >=2.32.3

The base URL to send all API requests is https://api.notion.com. 
Link to notion API documentation: https://developers.notion.com/reference/patch-block-children

Both request and responses are encoded as JSON. 

SECRET KEY: API access require creating an "internal integration app" in python, which would produce a secret key, by which you can use to access its API services. 
     https://www.notion.so/my-integrations.

# Message structure
1. Constant



JSON conventions
    - "object": Type of top-level resource (e.g database, user)
    - "id": Specific top level resource
    - *Property names* -> This is in a_b format
    - *Temporial values* -> date time in ISO 8601 string format
    - Does not support empty strings (e.g. ""). Use null value instead. 


Top-level resources are addressable by a UUIDv4 "id" property. You may omit dashes from the ID when making requests to the API, e.g. when copying the ID from a Notion URL.
Property names are in snake_case (not camelCase or kebab-case).
Temporal values (dates and datetimes) are encoded in ISO 8601 strings. Datetimes will include the time value (2020-08-12T02:12:33.231Z) while dates will include only the date (2020-08-12)
The Notion API does not support empty strings. To unset a string value for properties like a url Property value object, for example, use an explicit null instead of "".


Response database structure
    

'''
    Request structure
        
    Response structure


'''
# Change log
### [1.5.1] - 2024-09-08
add:
fixed:
1. get_logger: Direct import of logger variable does not change for files that import it when logger changes.
others:
### [1.5.0] - 2024-09-07
add:
1. insert_logger: takes in a class instance of log_data and place it in logger variable.
2. Logger: added a variable from which log_data operations can be executed from
3. Log method execution encapsulation in a try except block.
fixed:
others:
1. Log method execution encapsulation: To ensure that package operation is not affected by errors in log method.
### [1.4.1] - 2024-06-20
add:
1. Added logs to all functions, except test
fixed:
others:
### [1.4.0] - 2024-06-19
add:
1. pages: append_text_to_text_block function. Take a text block, and add more text to it
2. Pages: create_page_in_page function. Create a child page in a parent page.
3. Pages: add_text_blocks function. Add text blocks at the bottom of a page. 
4. Pages: extract_data_from_encapsulations operation, to extract only ids for each block
fixed:
others:
1. Objective that made me create these functions: custom_logger, store log data in notion if database storing fails. 
### [1.3.0] - 2024-06-18
add:
1. Pages: Create page in page function.
fixed:
others:
### [1.2.0] - 2024-06-18
add:
1. Pages: extract_data function created. (See explanation 1 in others section)
2. Pages: extract_all_direct_core_data_encapsulation (Using a single row, extract the data)
3. Pages: extract_data_from_encapsulations (apply specific rule meant for extracting specific data aspect). See explanation 2 and function source code to get a precise understanding. 
fixed:
others:
1. table: Comment out function execution at the bottom of the file, which was meant for testing
2. Explanation 1: Extract the encapsulation of the data (getting as close as possible to it) using a rule for all block types. Depending on the aspect of the data you want to extract (see explanation 2), use either extract_text or extract page function for each row data. Extract the data aspect. 
3. Explanation 2: page -> extract_page, text -> extract_text.
4. Why was these created: There are way too many block types and I cannot find a way to adapt previous operation to capture the core data of all various block types. Therefore, a new structure is created, where a parameter objective (currently either text or pages) is explicitly set in a parameter (data_type), and a specific pre-defined operation will be applied on all blocks, to produce outcomes that match that objective. 
### [1.1.1] - 2024-06-11
add:
1. Init: Added shortcut to table
fixed:
1. Table: Forgot to remove import statement to a package that does not exist (page)
others:
### [1.1.0] - 2024-06-11
add:
1. Table: plain table processing script.
2. extract_core_table_data: table to turn raw indented data from notion server to an array of array of strings. 
fixed:
others:
1. Incorporated generate_outcome_message function into page functions
2. Incorporated generate_outcome_message function into database functions
### [1.0.0] - 2024-06-08
add:
1. Database: Extract data from databases in notion
2. Page: Extract data from page
fixed:
others:
1. Notes: The description of the structure of the return value, because the structure of the return object has a lot of indentations and a lot of meta data. Purpose of notes is to make clear of where the core data is (e.g. text in a block). 
