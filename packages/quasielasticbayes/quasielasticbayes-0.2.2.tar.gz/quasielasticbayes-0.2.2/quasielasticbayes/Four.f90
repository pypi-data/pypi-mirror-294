      SUBROUTINE FOUR2 (DATA,N,NDIM,ISIGN,IFORM)
!     COOLEY-TUKEY FAST FOURIER TRANSFORM IN USASI BASIC FORTRAN.
!     MULTI-DIMENSIONAL TRANSFORM, EACH DIMENSION A POWER OF TWO,
!     COMPLEX OR REAL DATA.
!     TRANSFORM(K1,K2,...) = SUM(DATA(J1,J2,...)*EXP(ISIGN*2*PI*SQRT(-1)
!     *((J1-1)*(K1-1)/N(1)+(J2-1)*(K2-1)/N(2)+...))), SUMMED FOR ALL
!     J1 AND K1 FROM 1 TO N(1), J2 AND K2 FROM 1 TO N(2),
!     ETC. FOR ALL NDIM SUBSCRIPTS.  NDIM MUST BE POSITIVE AND
!     EACH N(IDIM) MUST BE A POWER OF TWO.  ISIGN IS +1 OR -1.
!     LET NTOT = N(1)*N(2)*...*N(NDIM).  THEN A -1 TRANSFORM
!     FOLLOWED BY A +1 ONE (OR VICE VERSA) RETURNS NTOT
!     TIMES THE ORIGINAL DATA.  IFORM = 1, 0 OR -1, AS DATA IS
!     COMPLEX, REAL OR THE FIRST HALF OF A COMPLEX ARRAY.	TRANSFORM
!     VALUES ARE RETURNED TO ARRAY DATA.  THEY ARE COMPLEX, REAL OR
!     THE FIRST HALF OF A COMPLEX ARRAY, AS IFORM = 1, -1 OR 0.
!     THE TRANSFORM OF A REAL ARRAY (IFORM = 0) DIMENSIONED N(1) BY N(2)
!     BY ... WILL BE RETURNED IN THE SAME ARRAY, NOW CONSIDERED TO
!     BE COMPLEX OF DIMENSIONS N(1)/2+1 BY N(2) BY ....  NOTE THAT IF
!     IFORM = 0 OR -1, N(1) MUST BE EVEN, AND ENOUGH ROOM MUST BE
!     RESERVED.  THE MISSING VALUES MAY BE OBTAINED BY COMPLEX CONJUGA-
!     TION.	THE REVERSE TRANSFORMATION, OF A HALF COMPLEX ARRAY DIMEN-
!     SIONED N(1)/2+1 BY N(2) BY ..., IS ACCOMPLISHED BY SETTING IFORM
!     TO -1.  IN THE N ARRAY, N(1) MUST BE THE TRUE N(1), NOT N(1)/2+1.
!     THE TRANSFORM WILL BE REAL AND RETURNED TO THE INPUT ARRAY.
!     RUNNING TIME IS PROPORTIONAL TO NTOT*LOG2(NTOT), RATHER THAN
!     THE NAIVE NTOT**2.  FURTHERMORE, LESS ERROR IS BUILT UP.
!     WRITTEN BY NORMAN BRENNER OF MIT LINCOLN LABORATORY, JUNE 1968.
!     SEE-- IEEE AUDIO TRANSACTIONS (JUNE 1967), SPECIAL ISSUE ON FFT.
INCLUDE 'res_par.f90'
DIMENSION DATA(m_d2), N(1)
NTOT=1
DO 10 IDIM=1,NDIM
10 NTOT=NTOT*N(IDIM)
IF (IFORM) 70,20,20
20 NREM=NTOT
DO 60 IDIM=1,NDIM
NREM=NREM/N(IDIM)
NPREV=NTOT/(N(IDIM)*NREM)
NCURR=N(IDIM)
IF (IDIM-1+IFORM) 30,30,40
30 NCURR=NCURR/2
40 CALL BOTRV (DATA,NPREV,NCURR,NREM)
CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
IF (IDIM-1+IFORM) 50,50,60
50 CALL FOXRL (DATA,N(1),NREM,ISIGN,IFORM)
NTOT=(NTOT/N(1))*(N(1)/2+1)
60 CONTINUE
RETURN
70 NTOT=(NTOT/N(1))*(N(1)/2+1)
NREM=1
DO 100 JDIM=1,NDIM
IDIM=NDIM+1-JDIM
NCURR=N(IDIM)
IF (IDIM-1) 80,80,90
80 NCURR=NCURR/2
CALL FOXRL (DATA,N(1),NREM,ISIGN,IFORM)
NTOT=NTOT/(N(1)/2+1)*N(1)
90 NPREV=NTOT/(N(IDIM)*NREM)
CALL BOTRV (DATA,NPREV,NCURR,NREM)
CALL COOL2 (DATA,NPREV,NCURR,NREM,ISIGN)
100 NREM=NREM*N(IDIM)
RETURN
END
SUBROUTINE FOXRL (DATA,N,NREM,ISIGN,IFORM)
!     FOR IFORM = 0, CONVERT THE TRANSFORM OF A DOUBLED-UP REAL ARRAY,
!     CONSIDERED COMPLEX, INTO ITS TRUE TRANSFORM.  SUPPLY ONLY THE
!     FIRST HALF OF THE COMPLEX TRANSFORM, AS THE SECOND HALF HAS
!     CONJUGATE SYMMETRY.  FOR IFORM = -1, CONVERT THE FIRST HALF
!     OF THE TRUE TRANSFORM INTO THE TRANSFORM OF A DOUBLED-UP REAL
!     ARRAY.  N MUST BE EVEN.
!     USING COMPLEX NOTATION AND SUBSCRIPTS STARTING AT ZERO, THE
!     TRANSFORMATION IS--
!     DIMENSION DATA(N,NREM)
!     ZSTP = EXP(ISIGN*2*PI*I/N)
!     DO 10 I2=0,NREM-1
!     DATA(0,I2) = CONJ(DATA(0,I2))*(1+I)
!     DO 10 I1=1,N/4
!     Z = (1+(2*IFORM+1)*I*ZSTP**I1)/2
!     I1CNJ = N/2-I1
!     DIF = DATA(I1,I2)-CONJ(DATA(I1CNJ,I2))
!     TEMP = Z*DIF
!     DATA(I1,I2) = (DATA(I1,I2)-TEMP)*(1-IFORM)
! 10  DATA(I1CNJ,I2) = (DATA(I1CNJ,I2)+CONJ(TEMP))*(1-IFORM)
!     IF I1=I1CNJ, THE CALCULATION FOR THAT VALUE COLLAPSES INTO
!     A SIMPLE CONJUGATION OF DATA(I1,I2).
INCLUDE 'res_par.f90'
DIMENSION DATA(m_d2)
TWOPI=6.283185307*FLOAT(ISIGN)
IP0=2
IP1=IP0*(N/2)
IP2=IP1*NREM
IF (IFORM) 10,70,70
!     PACK THE REAL INPUT VALUES (TWO PER COLUMN)
10 J1=IP1+1
DATA(2)=DATA(J1)
IF (NREM-1) 70,70,20
20 J1=J1+IP0
I2MIN=IP1+1
DO 60 I2=I2MIN,IP2,IP1
DATA(I2)=DATA(J1)
J1=J1+IP0
IF (N-2) 50,50,30
30 I1MIN=I2+IP0
I1MAX=I2+IP1-IP0
DO 40 I1=I1MIN,I1MAX,IP0
DATA(I1)=DATA(J1)
DATA(I1+1)=DATA(J1+1)
40 J1=J1+IP0
50 DATA(I2+1)=DATA(J1)
60 J1=J1+IP0
70 DO 80 I2=1,IP2,IP1
TEMPR=DATA(I2)
DATA(I2)=DATA(I2)+DATA(I2+1)
80 DATA(I2+1)=TEMPR-DATA(I2+1)
IF (N-2) 200,200,90
90 THETA=TWOPI/FLOAT(N)
SINTH=SIN(THETA/2.)
ZSTPR=-2.*SINTH*SINTH
ZSTPI=SIN(THETA)
ZR=(1.-ZSTPI)/2.
ZI=(1.+ZSTPR)/2.
IF (IFORM) 100,110,110
100 ZR=1.-ZR
ZI=-ZI
110 I1MIN=IP0+1
I1MAX=IP0*(N/4)+1
DO 190 I1=I1MIN,I1MAX,IP0
DO 180 I2=I1,IP2,IP1
I2CNJ=IP0*(N/2+1)-2*I1+I2
IF (I2-I2CNJ) 150,120,120
120 IF (ISIGN*(2*IFORM+1)) 130,140,140
130 DATA(I2+1)=-DATA(I2+1)
140 IF (IFORM) 170,180,180
150 DIFR=DATA(I2)-DATA(I2CNJ)
DIFI=DATA(I2+1)+DATA(I2CNJ+1)
TEMPR=DIFR*ZR-DIFI*ZI
TEMPI=DIFR*ZI+DIFI*ZR
DATA(I2)=DATA(I2)-TEMPR
DATA(I2+1)=DATA(I2+1)-TEMPI
DATA(I2CNJ)=DATA(I2CNJ)+TEMPR
DATA(I2CNJ+1)=DATA(I2CNJ+1)-TEMPI
IF (IFORM) 160,180,180
160 DATA(I2CNJ)=DATA(I2CNJ)+DATA(I2CNJ)
DATA(I2CNJ+1)=DATA(I2CNJ+1)+DATA(I2CNJ+1)
170 DATA(I2)=DATA(I2)+DATA(I2)
DATA(I2+1)=DATA(I2+1)+DATA(I2+1)
180 CONTINUE
TEMPR=ZR-.5
ZR=ZSTPR*TEMPR-ZSTPI*ZI+ZR
190 ZI=ZSTPR*ZI+ZSTPI*TEMPR+ZI
!     RECURSION SAVES TIME, AT A SLIGHT LOSS IN ACCURACY.	IF AVAILABLE,
!     USE DOUBLE PRECISION TO COMPUTE ZR AND ZI.
200 IF (IFORM) 270,210,210
!     UNPACK THE REAL TRANSFORM VALUES (TWO PER COLUMN)
210 I2=IP2+1
I1=I2
J1=IP0*(N/2+1)*NREM+1
GO TO 250
220 DATA(J1)=DATA(I1)
DATA(J1+1)=DATA(I1+1)
I1=I1-IP0
J1=J1-IP0
230 IF (I2-I1) 220,240,240
240 DATA(J1)=DATA(I1)
DATA(J1+1)=0.
250 I2=I2-IP1
J1=J1-IP0
DATA(J1)=DATA(I2+1)
DATA(J1+1)=0.
I1=I1-IP0
J1=J1-IP0
IF (I2-1) 260,260,230
260 DATA(2)=0.
270 RETURN
END
SUBROUTINE BOTRV(DATA,NPREV,N,NREM)
!   SHUFFLE THE DATA BY 'BIT REVERSAL'.
!   DIMENSION DATA(NPREV,N,NREM)
!   DATA(I1,I2REV,I3) = DATA(I1,I2,I3), FOR ALL I1 FROM 1 TO
!   NPREV, ALL I2 FROM 1 TO N (WHICH MUST BE A POWER OF TWO), AND
!   ALL I3 FROM 1 TO NREM, WHERE I2REV-1 IS THE BITWISE REVERSAL
!   OF I2-1.  FOR EXAMPLE, N = 32, I2-1 = 10011 AND I2REV-1 = 11001.
!
INCLUDE 'res_par.f90'
DIMENSION DATA(m_d2)
COMPLEX DATA,TEMP
IP0=1
IP1=IP0*NPREV
IP4=IP1*N
IP5=IP4*NREM
I4REV=1
I4MAX=IP4
DO 60 I4=1,I4MAX,IP1
IF(I4-I4REV)10,30,30
10 I1MAX=I4+IP1-IP0
DO 20 I1=I4,I1MAX,IP0
DO 20 I5=I1,IP5,IP4
I5REV=I4REV+I5-I4
TEMP=DATA(I5)
DATA(I5)=DATA(I5REV)
20 DATA(I5REV)=TEMP
30 IP2=IP4/2
40 IF(I4REV-IP2)60,60,50
50 I4REV=I4REV-IP2
IP2=IP2/2
IF(IP2-IP1)60,40,40
60 I4REV=I4REV+IP2
RETURN
END
SUBROUTINE COOL2(DATA,NPREV,N,NREM,ISIGN)
!   FOURIER TRANSFORM, LENGTH N, BY THE COOLEY-TUKEY ALGORITHM, IN
!   PLACE, BIT-REVERSED TO NORMAL ORDER, SANDE-TUKEY PHASE SHIFTS.
!   COMPLEX DATA
!   DIMENSION DATA(NPREV,N,NREM)
!   DATA(I1,J2,I3) = SUM(DATA(I1,I2,I3)CEXP(ISIGNC2CPICIC((I2-1)C
!   (J2-1)/N))), SUMMED OVER I2 = 1 TO N FOR ALL I1 FROM 1 TO
!   NPREV, J2 FROM 1 TO N AND I3 FROM 1 TO NREM.  N MUST BE A
!   POWER OF TWO.  FACTORING N BY FOUR'S DECREASES RUNNING TIME
!   BY ABOUT TWENTY FIVE PERCENT OVER FACTORING BY TWO'S.
!   GENERATING THE PHASE SHIFT FACTORS BY RECURSION SAVES ABOUT
!   TWENTY FIVE PERCENT OVER COMPUTING THEM, WHILE TABLING THEM
!   IS UNLIKELY TO SAVE MORE THAN ANOTHER TEN PERCENT.
!
INCLUDE 'res_par.f90'
DIMENSION DATA(m_d2)
COMPLEX DATA,TEMP,WSTP,W,W2,W3,T0,T1,T2,T3
TWOPI=6.28318530717958647692*FLOAT(ISIGN)
IP0=1
IP1=IP0*NPREV
IP4=IP1*N
IP5=IP4*NREM
IP2=IP1
NPART=N
10 IF(NPART-2)50,30,20
20 NPART=NPART/4
GO TO 10
!
!   DO A FOURIER TRANSFORM OF LENGTH TWO
!
30 IP3=IP2*2
I1MAX=IP1
DO 40 I1=1,I1MAX,IP0
DO 40 I5=I1,IP5,IP3
I3A=I5
I3B=I3A+IP2
TEMP=DATA(I3B)
DATA(I3B)=DATA(I3A)-TEMP
40 DATA(I3A)=DATA(I3A)+TEMP
GO TO 140
!
!   DO A FOURIER TRANSFORM OF LENGTH FOUR (WITHOUT BIT REVERSAL)
!
50 IP3=IP2*4
THETA=TWOPI/FLOAT(IP3/IP1)
SINTH=SIN(THETA/2.)
WSTP=CMPLX(-2.*SINTH*SINTH,SIN(THETA))
!
!   COS(THETA)-1, FOR ACCURACY
!
W=1.
DO 130 I2=1,IP2,IP1
 IF(I2-1)70,70,60
60 W2=W*W
W3=W2*W
70 I1MAX=I2+IP1-IP0
DO 120 I1=I2,I1MAX,IP0
DO 120 I5=I1,IP5,IP3
I3A=I5
I3B=I3A+IP2
I3C=I3B+IP2
I3D=I3C+IP2
IF(I2-1)90,90,80
!
!   MULTIPLY BY THE PHASE SHIFT FACTORS
!
80 DATA(I3B)=W2*DATA(I3B)
DATA(I3C)=W*DATA(I3C)
DATA(I3D)=W3*DATA(I3D)
90 T0=DATA(I3A)+DATA(I3B)
T1=DATA(I3A)-DATA(I3B)
T2=DATA(I3C)+DATA(I3D)
T3=DATA(I3C)-DATA(I3D)
DATA(I3A)=T0+T2
DATA(I3C)=T0-T2
TEMP=(0.,1.)*T3
IF(ISIGN)100,100,110
100 TEMP=-TEMP
110 DATA(I3B)=T1+TEMP
120 DATA(I3D)=T1-TEMP
130 W=W*WSTP+W
140 IP2=IP3
IF(IP3-IP4)50,150,150
150 RETURN
END
