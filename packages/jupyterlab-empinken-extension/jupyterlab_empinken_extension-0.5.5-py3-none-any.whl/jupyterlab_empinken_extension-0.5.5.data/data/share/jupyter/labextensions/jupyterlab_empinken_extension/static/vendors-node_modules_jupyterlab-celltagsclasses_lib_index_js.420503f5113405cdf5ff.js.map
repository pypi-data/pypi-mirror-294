{"version":3,"file":"vendors-node_modules_jupyterlab-celltagsclasses_lib_index_js.420503f5113405cdf5ff.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO,KAAK,oBAAoB;AAChF;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACwD;AACD;AACA;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,iEAAe;AAChD;AACA;AACA;AACA,YAAY,oEAAoB;AAChC;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB;AACpE;AACA;AACA,0EAA0E,mBAAmB;AAC7F;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,mBAAmB;AAC7F;AACA,iCAAiC;AACjC;AACA,4EAA4E,mBAAmB;AAC/F;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6EAA6E,mBAAmB;AAChG;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,+EAA+E,mBAAmB;AAClG;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA,iEAAe,MAAM,EAAC;AACtB;AAC2H;AAClE;;;;;;;;;;;;;;;;;;;;;;;;;;ACvGzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACwE;AACjH;AACO;AACP,wBAAwB,mDAAI;AAC5B;AACA;AACA,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAS;AACxB;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAS;AAC5B;AACA;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAS;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAY;AACnC;AACA;AACA;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAY;AACnC;AACA;AACA;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,iDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClNyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,gBAAgB,+DAAc;AAC9B,aAAa;AACb,SAAS;AACT,0BAA0B,sCAAsC;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8EAA8E,kDAAK;AACnF,qFAAqF,kDAAK;AAC1F,kEAAkE,kDAAK;AACvE;AACA,uEAAuE,kDAAK;AAC5E,8EAA8E,kDAAK;AACnF,2DAA2D,kDAAK;AAChE;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB;AAClB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO,SAAS,WAAW;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlab_empinken_extension/./node_modules/jupyterlab-celltagsclasses/lib/apply_on_cells.js","webpack://jupyterlab_empinken_extension/./node_modules/jupyterlab-celltagsclasses/lib/index.js","webpack://jupyterlab_empinken_extension/./node_modules/jupyterlab-celltagsclasses/lib/metadata.js","webpack://jupyterlab_empinken_extension/./node_modules/jupyterlab-celltagsclasses/lib/test_commands.js","webpack://jupyterlab_empinken_extension/./node_modules/jupyterlab-celltagsclasses/lib/xpath.js"],"sourcesContent":["/*\n * the logic of applying a function on a set of cells\n */\nexport var Scope;\n(function (Scope) {\n    Scope[Scope[\"All\"] = 0] = \"All\";\n    Scope[Scope[\"Active\"] = 1] = \"Active\";\n    Scope[Scope[\"Multiple\"] = 2] = \"Multiple\";\n})(Scope || (Scope = {}));\n// because this function is designed to define global commands\n// we always act on notebookTracker.currentWidget\n// i.e. the currently active notebook panel\nexport const apply_on_cells = (notebookTracker, scope, to_apply) => {\n    var _a;\n    const notebook = (_a = notebookTracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content;\n    if (notebook === undefined) {\n        // not focusing on a notebook..\n        return;\n    }\n    let actionCells;\n    if (scope === Scope.All) {\n        actionCells = notebook.widgets.slice();\n    }\n    else {\n        const activeCell = notebook.activeCell;\n        if (activeCell === null) {\n            return;\n        }\n        if (scope === Scope.Active) {\n            actionCells = [activeCell];\n        }\n        else {\n            const { anchor, head } = notebook.getContiguousSelection();\n            // when only one cell is selected/active, both are null\n            if (anchor === null || head === null) {\n                actionCells = [activeCell];\n            }\n            else {\n                actionCells = notebook.widgets.slice(anchor, head + 1);\n            }\n        }\n    }\n    // console.log(`apply_on_cells with scope=${scope} on ${actionCells.length} cells`)\n    actionCells.forEach(to_apply);\n};\n","/*\n * for attaching keybindings later on, see\n * https://towardsdatascience.com/how-to-customize-jupyterlab-keyboard-shortcuts-72321f73753d\n */\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { create_test_commands } from './test_commands';\n// turn that to true to do manual tests of apply_on_cells\nconst SHIP_TEST_COMMANDS = true;\n/**\n * Initialization data for the jupyterlab-celltagsclasses extension.\n */\nconst plugin = {\n    id: 'jupyterlab-celltagsclasses:plugin',\n    autoStart: true,\n    requires: [INotebookTracker, ICommandPalette],\n    activate: (app, notebookTracker, palette) => {\n        console.log('extension jupyterlab-celltagsclasses is activating');\n        if (SHIP_TEST_COMMANDS) {\n            create_test_commands(app, notebookTracker, palette);\n        }\n        const class_for_tag = (tag) => `cell-tag-${tag}`;\n        notebookTracker.widgetAdded.connect((_, panel) => {\n            const notebookModel = panel.content.model;\n            if (notebookModel === null) {\n                return;\n            }\n            notebookModel.cells.changed.connect((cellList, change) => {\n                if (change.type !== 'add') {\n                    return;\n                }\n                change.newValues.forEach(cellModel => {\n                    var _a;\n                    // compute widgets attached to cellModel\n                    const cellWidgets = panel.content.widgets.filter((cell, index) => cell.model.id === cellModel.id);\n                    if (cellWidgets === undefined || (cellWidgets === null || cellWidgets === void 0 ? void 0 : cellWidgets.length) === 0) {\n                        // console.warn('could not find cell widget for cell model', cellModel)\n                        return;\n                    }\n                    // console.debug( `found ${cellWidgets?.length} cell widgets`, cellWidgets[0] )\n                    // add classes for pre-existing tags\n                    (_a = cellModel.getMetadata('tags')) === null || _a === void 0 ? void 0 : _a.forEach((tag) => cellWidgets === null || cellWidgets === void 0 ? void 0 : cellWidgets.forEach(cellWidget => {\n                        // console.debug( `adding initial class for tag ${class_for_tag(tag)}` )\n                        cellWidget.addClass(class_for_tag(tag));\n                    }));\n                    // react to changes in tags\n                    cellModel.metadataChanged.connect((sender, change) => {\n                        // console.debug('metadata changed', sender, change)\n                        if (change.key !== 'tags') {\n                            // console.debug(\"ignoring non-tags metadata change\")\n                            return;\n                        }\n                        // does not seem useful to recompute this\n                        // const cellWidgets = panel.content.widgets.filter(\n                        //   (cell: Cell, index: number) => (cell.model.id === cellModel.id)\n                        // )\n                        if (change.type === 'change') {\n                            // console.debug('change', change, change.newValue)\n                            // compute difference between old and new tags\n                            const oldTags = change.oldValue;\n                            const newTags = change.newValue;\n                            const addedTags = newTags.filter(tag => !oldTags.includes(tag));\n                            const removedTags = oldTags.filter(tag => !newTags.includes(tag));\n                            // console.debug('addedTags', addedTags)\n                            // console.debug('removedTags', removedTags)\n                            cellWidgets.forEach(cellWidget => {\n                                addedTags.forEach(tag => {\n                                    console.debug(`adding class for tag ${class_for_tag(tag)}`);\n                                    cellWidget.addClass(class_for_tag(tag));\n                                });\n                                removedTags.forEach(tag => {\n                                    console.debug(`removing class for tag ${class_for_tag(tag)}`);\n                                    cellWidget.removeClass(class_for_tag(tag));\n                                });\n                            });\n                        }\n                        else if (change.type === 'add') {\n                            console.debug('celltagsclasses: add', change, change.newValue);\n                            cellWidgets.forEach(cellWidget => {\n                                for (const tag of change.newValue) {\n                                    // console.debug(`adding class for tag ${class_for_tag(tag)}`)\n                                    cellWidget.addClass(class_for_tag(tag));\n                                }\n                            });\n                        }\n                        else if (change.type === 'remove') {\n                            console.debug('celltagsclasses: remove', change, change.newValue);\n                            cellWidgets.forEach(cellWidget => {\n                                for (const tag of change.newValue) {\n                                    // console.debug(`removing class for tag ${class_for_tag(tag)}`)\n                                    cellWidget.removeClass(class_for_tag(tag));\n                                }\n                            });\n                        }\n                    });\n                });\n            });\n        });\n    },\n};\nexport default plugin;\n// re-export metadata helper functions\nexport { md_get, md_set, md_unset, md_has, md_insert, md_remove, md_toggle, md_toggle_multi, md_clean, } from './metadata';\nexport { Scope, apply_on_cells } from './apply_on_cells';\n","/* eslint-disable prettier/prettier */\n//\n// Metadata helper tools\n// a xpath can be either a dot-separated string, or an array of strings\n//\n//  single valued metadata:\n//\n// (*) md_get: get a metadata value\n//         e.g. md_get(cell, \"some.path.in.the.metadata\")\n//           or md_get(cell, \"some.path.in.the.metadata\", \"default value\")\n//           or md_get(cell, [\"some\", \"path\", \"in\", \"the\", \"metadata\"])\n// (*) md_set: set a metadata value\n//         e.g. md_set(cell, \"some.path.in.the.metadata\", \"new value\")\n// (*) md_unset: unset a metadata value\n//         e.g. md_unset(cell, \"some.path.in.the.metadata\")\n//\n//  list valued metadata (typically xpath = 'tags')\n//\n// (*) md_has: check if a value is present in a metadata list\n//         e.g. md_has(cell, \"path.to.tags\", \"tag-to-check\")\n// (*) md_insert: insert a value in a metadata list\n//         e.g. md_insert(cell, \"path.to.tags\", \"added-tag\")\n// (*) md_remove: remove a value from a metadata list\n//         e.g. md_remove(cell, \"path.to.tags\", \"removed-tag\")\n// (*) md_toggle: toggle a value in a metadata list\n//         e.g. md_toggle(cell, \"path.to.tags\", \"toggled-tag\")\n// (*) md_toggle_multi: toggle a value in a metadata list,\n//        removing the other values in the lists\n//\n// clean up\n// (*) md_clean: remove empty metadata elements\n//         e.g. md_clean(cell, \"path.to.subtree\")\n//         or more typically\n//              md_clean(cell, \"\")\n//          will alter the cell's metadata so as to remove empty lists or empty keys\nimport { Cell } from '@jupyterlab/cells';\nimport { normalize, xpath_get, xpath_set, xpath_unset, xpath_insert, xpath_remove, xpath_clean, } from './xpath';\n// atomic values\nexport const md_get = (cell, xpath, if_missing) => {\n    if (cell instanceof Cell) {\n        cell = cell.model;\n    }\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    const start = cell.getMetadata(first);\n    if (start === undefined) {\n        return if_missing;\n    }\n    else {\n        return xpath_get(start, tail);\n    }\n};\nexport const md_set = (cell, xpath, value) => {\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    const start = cell.model.getMetadata(first);\n    if (tail.length === 0) {\n        cell.model.setMetadata(first, value);\n        return value;\n    }\n    const subtree = start || {};\n    const retcod = xpath_set(subtree, tail, value);\n    cell.model.setMetadata(first, subtree);\n    return retcod;\n};\nexport const md_unset = (cell, xpath) => {\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    const start = cell.model.getMetadata(first);\n    if (start === undefined) {\n        return false;\n    }\n    if (tail.length === 0) {\n        cell.model.deleteMetadata(first);\n        return true;\n    }\n    else {\n        const retcod = xpath_unset(start, tail);\n        cell.model.setMetadata(first, start);\n        return retcod;\n    }\n};\n// lists (e.g. tags)\nexport const md_has = (cell, xpath, key) => {\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    const start = cell.model.getMetadata(first);\n    if (start === undefined) {\n        return false;\n    }\n    const list = xpath_get(start, tail);\n    if (list === undefined) {\n        return false;\n    }\n    return list.indexOf(key) >= 0;\n};\nexport const md_insert = (cell, xpath, key) => {\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    const start = cell.model.getMetadata(first);\n    if (tail.length === 0) {\n        let sublist;\n        if (start !== undefined) {\n            sublist = start;\n            // use another object as otherwise .setMetadata() does not seem to propagate\n            sublist = sublist.slice();\n        }\n        else {\n            sublist = [];\n        }\n        if (sublist.indexOf(key) < 0) {\n            sublist.push(key);\n            cell.model.setMetadata(first, sublist);\n            return key;\n        }\n        else {\n            return undefined;\n        }\n    }\n    else {\n        const subtree = start || {};\n        const retcod = xpath_insert(subtree, tail, key);\n        cell.model.setMetadata(first, subtree);\n        return retcod;\n    }\n};\nexport const md_remove = (cell, xpath, key) => {\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    const start = cell.model.getMetadata(first);\n    if (start === undefined) {\n        return undefined;\n    }\n    if (tail.length === 0) {\n        const sublist = start;\n        if (!(sublist instanceof Array)) {\n            return undefined;\n        }\n        // use another object as otherwise .set() does not seem to propagate\n        const copy = sublist.slice();\n        const index = copy.indexOf(key);\n        if (index < 0) {\n            return undefined;\n        }\n        // const as_array = sublist as Array<string>\n        copy.splice(index, 1);\n        cell.model.setMetadata(first, copy);\n        return key;\n    }\n    else {\n        const subtree = start;\n        const retcod = xpath_remove(subtree, tail, key);\n        cell.model.setMetadata(first, subtree);\n        return retcod;\n    }\n};\nexport const md_toggle = (cell, xpath, key) => {\n    xpath = normalize(xpath);\n    if (!md_has(cell, xpath, key)) {\n        return md_insert(cell, xpath, key);\n    }\n    else {\n        return md_remove(cell, xpath, key);\n    }\n};\n/*\n * given a within_set of mututally exclusive keys\n * e.g. within_set = ['level1', 'level2', 'level3']\n * and a key to toggle\n * md_toggle_multi will toggle the key and unset the other keys\n * in the event where key is not in within_set\n * the effect of this function is to clear all keys in within_set\n */\nexport const md_toggle_multi = (cell, xpath, key, within_set) => {\n    if (within_set.includes(key)) {\n        md_toggle(cell, xpath, key);\n    }\n    for (const other_key of within_set) {\n        if (other_key !== key) {\n            md_remove(cell, xpath, other_key);\n        }\n    }\n};\nexport const md_clean = (cell, xpath) => {\n    xpath = normalize(xpath);\n    const [first, ...tail] = xpath;\n    if (first === undefined) {\n        console.log(cell.model.metadata);\n        // no xpath, clean the whole metadata\n        for (const key of Object.entries(cell.model.metadata)) {\n            const xpath = key;\n            const new_value = xpath_clean(md_get(cell, xpath), '');\n            if (new_value === undefined || new_value.length === 0) {\n                md_unset(cell, xpath);\n            }\n            else {\n                md_set(cell, xpath, new_value);\n            }\n        }\n    }\n    else {\n        const subtree = md_get(cell, first);\n        const new_value = xpath_clean(subtree, tail);\n        if (new_value === undefined || new_value.length === 0) {\n            md_unset(cell, first);\n        }\n        else {\n            md_set(cell, first, new_value);\n        }\n    }\n};\n","import { Scope, apply_on_cells } from './apply_on_cells';\n// apply_on_cell calls action on a Cell (Widget) object\n// use cell.model if a CellModel is needed\nconst cell_action = (cell) => {\n    console.log('cell_action on', cell.node);\n};\n// act on models\n// like so for example\nconst model_action = (cell) => {\n    console.log('model_action on', cell.node);\n    const model = cell.model;\n    const source = cell.model.sharedModel.getSource();\n    model.sharedModel.setSource(source.toUpperCase());\n};\nexport const create_test_commands = (app, notebookTracker, palette) => {\n    const add_command = (suffix, label, scope, keys, the_function) => {\n        const command = `celltagsclasses:${suffix}`;\n        app.commands.addCommand(command, {\n            label,\n            execute: () => {\n                console.log(label);\n                apply_on_cells(notebookTracker, scope, the_function);\n            },\n        });\n        palette.addItem({ command, category: 'celltagsclasses' });\n        app.commands.addKeyBinding({\n            command,\n            keys,\n            selector: '.jp-Notebook',\n        });\n    };\n    // MODEL\n    add_command('single-model', 'perform model action on single active cell', Scope.Active, ['Alt-K', 'Alt-1'], model_action);\n    add_command('multiple-model', 'perform model action on multiple selected cells', Scope.Multiple, ['Alt-K', 'Alt-2'], model_action);\n    add_command('all-model', 'perform model action on all cells', Scope.All, ['Alt-K', 'Alt-3'], model_action);\n    // CELL\n    add_command('single-cell', 'perform action on single active cell', Scope.Active, ['Alt-K', 'Alt-4'], cell_action);\n    add_command('multiple-cell', 'perform action on multiple selected cells', Scope.Multiple, ['Alt-K', 'Alt-5'], cell_action);\n    add_command('all-cell', 'perform action on all cells', Scope.All, ['Alt-K', 'Alt-6'], cell_action);\n};\n","/* eslint-disable no-case-declarations */\n/* eslint-disable prettier/prettier */\n// helpers to manage a JS object\n//\n// in this module we are only concerned about doing side effects\n// in a JavaScript object\n// what to do on the passed object\nvar Action;\n(function (Action) {\n    Action[Action[\"Get\"] = 0] = \"Get\";\n    Action[Action[\"Set\"] = 1] = \"Set\";\n    Action[Action[\"Unset\"] = 2] = \"Unset\";\n    Action[Action[\"Insert\"] = 3] = \"Insert\";\n    Action[Action[\"Remove\"] = 4] = \"Remove\";\n})(Action || (Action = {}));\nexport const normalize = (xpath) => {\n    if (typeof xpath === 'string') {\n        const string = xpath;\n        if (string.length === 0) {\n            return [];\n        }\n        return string.split('.');\n    }\n    else if (xpath instanceof Array) {\n        return xpath;\n    }\n    else {\n        console.error(`xpath must be string or array, got ${xpath}`);\n        return [];\n    }\n};\nconst _manage_metadata = (data, // intended to be cell.metadata\naction, xpath, value) => {\n    const { Get, Set, Unset, Insert, Remove } = Action;\n    const recurse = (scanner, action, xpath, value) => {\n        // console.log(`in recurse with xpath=${xpath}`)\n        if (xpath.length === 0) {\n            switch (action) {\n                case Get:\n                    return scanner;\n                default:\n                    return undefined;\n            }\n        }\n        else if (xpath.length === 1) {\n            const [step] = xpath;\n            //\n            switch (action) {\n                case Get:\n                    return scanner[step];\n                case Set:\n                    scanner[step] = value;\n                    return value;\n                case Unset:\n                    if (step in scanner) {\n                        delete scanner[step];\n                        return true;\n                    }\n                    else {\n                        return false;\n                    }\n                case Insert:\n                    // create list if needed\n                    if (!(step in scanner)) {\n                        scanner[step] = [];\n                    }\n                    if (!(scanner[step] instanceof Array)) {\n                        return undefined;\n                    }\n                    // insert if not already present\n                    {\n                        const list = scanner[step];\n                        if (list.indexOf(value) < 0) {\n                            list.push(value);\n                            return value;\n                        }\n                        else {\n                            return undefined;\n                        }\n                    }\n                case Remove:\n                    if (!(scanner[step] instanceof Array)) {\n                        return undefined;\n                    }\n                    const list = scanner[step];\n                    // list.pop(value) is not accepted by ts ?!?\n                    const index = list.indexOf(value);\n                    if (index >= 0) {\n                        list.splice(index, 1);\n                    }\n                    return value;\n            }\n        }\n        else {\n            const [first, ...rest] = xpath;\n            if (first in scanner) {\n                if (!(scanner[first] instanceof Object)) {\n                    return undefined;\n                }\n                else {\n                    const next = scanner[first];\n                    return recurse(next, action, rest, value);\n                }\n            }\n            else {\n                switch (action) {\n                    case Get:\n                        return undefined;\n                    case Set:\n                        scanner[first] = {};\n                        const next = scanner[first];\n                        return recurse(next, action, rest, value);\n                    case Unset:\n                        return undefined;\n                    case Insert:\n                        if (rest.length === 0) {\n                            scanner[first] = [];\n                            return recurse(scanner[first], action, rest, value);\n                        }\n                        else {\n                            scanner[first] = {};\n                            return recurse(scanner[first], action, rest, value);\n                        }\n                    case Remove:\n                        return undefined;\n                }\n            }\n        }\n    };\n    const xpath_list = normalize(xpath);\n    return recurse(data, action, xpath_list, value);\n};\nconst _clean_metadata = (data, xpath) => {\n    const not_empty = (x) => {\n        if (x instanceof Array) {\n            return x.length !== 0;\n        }\n        else if (x instanceof Object) {\n            return Object.keys(x).length !== 0;\n        }\n        else if (typeof x === 'string') {\n            return x.length !== 0;\n        }\n        else {\n            return true;\n        }\n    };\n    const clean_array = (data) => {\n        return data.map(clean).filter(not_empty);\n    };\n    const clean_object = (data) => {\n        const result = {};\n        for (const key in data) {\n            const value = data[key];\n            const cleaned = clean(value);\n            if (not_empty(cleaned)) {\n                result[key] = cleaned;\n            }\n        }\n        return result;\n    };\n    const clean = (data) => {\n        if (data instanceof Array) {\n            return clean_array(data);\n        }\n        else if (data instanceof Object) {\n            return clean_object(data);\n        }\n        else {\n            return data;\n        }\n    };\n    const xpath_list = normalize(xpath);\n    if (xpath_list.length === 0) {\n        return clean(data);\n    }\n    else {\n        const start = xpath_get(data, xpath_list);\n        if (start === undefined) {\n            // nothing serious here, just a debug message\n            //console.debug(`DBG: xpath_clean: nothing to clean at ${xpath} - from ${xpath_list}`)\n            return data;\n        }\n        else {\n            return xpath_set(data, xpath_list, clean(start));\n        }\n    }\n};\nexport const xpath_get = (metadata, xpath) => _manage_metadata(metadata, Action.Get, xpath, undefined);\nexport const xpath_set = (metadata, xpath, value) => _manage_metadata(metadata, Action.Set, xpath, value);\nexport const xpath_unset = (metadata, xpath) => _manage_metadata(metadata, Action.Unset, xpath, undefined);\nexport const xpath_insert = (metadata, xpath, key) => _manage_metadata(metadata, Action.Insert, xpath, key);\nexport const xpath_remove = (metadata, xpath, key) => _manage_metadata(metadata, Action.Remove, xpath, key);\nexport const xpath_clean = (metadata, xpath) => _clean_metadata(metadata, xpath);\n"],"names":[],"sourceRoot":""}