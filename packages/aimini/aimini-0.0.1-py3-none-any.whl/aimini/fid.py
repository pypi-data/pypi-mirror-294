# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/lectures/18_fid.ipynb.

# %% auto 0
__all__ = ['ImageEval']

# %% ../nbs/lectures/18_fid.ipynb 2
import fastcore.all as fc
from scipy import linalg
import math
from matplotlib import pyplot as plt

import torch
from torch import tensor, nn
import torchvision.transforms.functional as TF
import torch.nn.functional as F
from torch.utils.data import DataLoader
from torcheval.metrics import MulticlassAccuracy

from .datasets import inplace, load_dataset, show_images
from .learner import DataLoaders, DeviceCB, Learner, to_cpu, TrainLearner, MetricsCB
from .accel import MixedPrecision
from .activations import HooksCallback
from .augment import capture_preds
from .init import clean_mem

# %% ../nbs/lectures/18_fid.ipynb 31
def _calc_stats(feats):
    feats = feats.squeeze()
    return feats.mean(0), feats.T.cov()

# %% ../nbs/lectures/18_fid.ipynb 33
def _sqrtm_newton_schulz(mat, num_iters=100):
    mat_nrm = mat.norm()
    mat = mat.double()
    Y = mat / mat_nrm
    n = len(mat)
    I = torch.eye(n, n).to(mat)
    Z = torch.eye(n, n).to(mat)

    for i in range(num_iters):
        T = (3*I - Z@Y) / 2
        Y, Z = Y@T, T@Z
        res = Y*mat_nrm.sqrt()
        if ((mat - (res@res)).norm() / mat_nrm).abs() <= 1e-6: break
    return res

# %% ../nbs/lectures/18_fid.ipynb 35
def _calc_fid(m1, c1, m2, c2):
    # car = _sqrtm_newton_schulz(c1 @ c2)
    csr = tensor(linalg.sqrtm(c1@c2, 256).real)
    return (((m1-m2)**2).sum() + c1.trace() + c2.trace() - 2 * csr.trace()).item()

# %% ../nbs/lectures/18_fid.ipynb 37
def _squared_mmd(x, y):
    def k(a, b): return (a@b.transpose(-2, -1)/a.shape[-1]+1)**3
    m, n = x.shape[-2], y.shape[-2]
    kxx, kyy, kxy = k(x, x), k(y, y), k(x, y)
    kxx_sum = kxx.sum([-1, -2]) - kxx.diagonal(0, -1, -2).sum(-1)
    kyy_sum = kyy.sum([-1, -2]) - kyy.diagonal(0, -1, -2).sum(-1)
    kxy_sum = kxy.sum([-1, -2])
    return kxx_sum/m/(m-1) + kyy_sum/n/(n-1) - kxy_sum*2/m/n

# %% ../nbs/lectures/18_fid.ipynb 38
def _calc_kid(x, y, maxs=50):
    xs, ys = x.shape[0], y.shape[0]
    n = max(math.ceil(min(xs/maxs, ys/maxs)), 4)
    mmd = 0.
    for i in range(n):
        cur_x = x[round(i*xs/n) : round((i+1)*xs/n)]
        cur_y = y[round(i*ys/n) : round((i+1)*ys/n)]
        mmd += _squared_mmd(cur_x, cur_y)
    return (mmd/n).item()

# %% ../nbs/lectures/18_fid.ipynb 41
class ImageEval:
    def __init__(self, model, dls, cbs=None):
        self.learn = TrainLearner(model, dls, loss_func=fc.noop, cbs=cbs, opt_func=None)
        self.feats = self.learn.capture_preds()[0].float().cpu().squeeze()
        self.stats = _calc_stats(self.feats)

    def get_feats(self, samp):
        self.learn.dls = DataLoaders([], [(samp, tensor([0]))])
        return self.learn.capture_preds()[0].float().cpu().squeeze()

    def fid(self, samp): return _calc_fid(*self.stats, *_calc_stats(self.get_feats(samp)))
    def kid(self, samp): return _calc_kid(self.feats, self.get_feats(samp))
