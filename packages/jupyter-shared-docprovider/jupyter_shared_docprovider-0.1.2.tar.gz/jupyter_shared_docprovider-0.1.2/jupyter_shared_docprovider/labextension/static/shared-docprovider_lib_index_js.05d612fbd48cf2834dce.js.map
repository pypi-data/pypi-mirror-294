{"version":3,"file":"shared-docprovider_lib_index_js.05d612fbd48cf2834dce.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACoD;AACS;AACpC;AACkB;AACgB;AAC3D,WAAW,mBAAmB;AAC0B;AACZ;AAC5C,oCAAoC,6DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe,GAAG,oBAAoB,GAAG,aAAa;AACjF,iCAAiC,qDAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gCAAgC,qDAAM;AACtC;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAM;AAClD;AACA,SAAS;AACT;AACA,mCAAmC,oCAAK;AACxC;AACA,uCAAuC,oDAAe;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gGAAgG,cAAc;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI,GAAG,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oCAAK;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe,GAAG,aAAa,GAAG,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,2BAA2B,eAAe,GAAG,aAAa,GAAG,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,MAAM,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;AACG;AACF;;;;;;;;;;;;;;;;;;;;;ACVzB;AACA;AACA;AACA;AACoD;AACT;AACkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA,oCAAoC,oDAAe,IAAI,aAAa,GAAG,kBAAkB,GAAG,YAAY;AACxG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7FA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,yBAAyB,oDAAK","sources":["webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/drive.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/index.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/provider.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { WebrtcProvider as YWebrtcProvider } from 'y-webrtc';\nimport * as Y from 'yjs';\nimport { Signal } from '@lumino/signaling';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\n//import { ServerConnection } from './serverconnection';\nimport { ServerConnection } from '@jupyterlab/services';\nimport { WebrtcProvider } from './provider';\nconst signalingServers = JSON.parse(PageConfig.getOption('signalingServers'));\nconst MODEL = {\n    name: '',\n    path: '',\n    type: '',\n    writable: true,\n    created: '',\n    last_modified: '',\n    mimetype: '',\n    content: '',\n    format: null\n};\n/**\n * A collaborative implementation for an `IDrive`, talking to other peers using WebRTC.\n */\nexport class SharedDrive {\n    /**\n     * Construct a new drive object.\n     *\n     * @param user - The user manager to add the identity to the awareness of documents.\n     */\n    constructor(user, defaultFileBrowser, translator, globalAwareness, name) {\n        this._onSync = (synced) => {\n            var _a;\n            if (synced.synced) {\n                this._ready.resolve();\n                (_a = this._fileSystemProvider) === null || _a === void 0 ? void 0 : _a.off('synced', this._onSync);\n            }\n        };\n        this._onCreate = (options, sharedModel) => {\n            if (typeof options.format !== 'string') {\n                return;\n            }\n            const file = this._fileSystemContent.get(options.path);\n            if (file === undefined) {\n                return;\n            }\n            const key = `${options.format}:${options.contentType}:${options.path}`;\n            const provider = new WebrtcProvider({\n                url: '',\n                path: options.path,\n                format: options.format,\n                contentType: options.contentType,\n                model: sharedModel,\n                user: this._user,\n                translator: this._trans,\n                signalingServers: this._signalingServers\n            });\n            this._fileProviders.set(key, provider);\n            sharedModel.disposed.connect(() => {\n                const provider = this._fileProviders.get(key);\n                if (provider) {\n                    provider.dispose();\n                    this._fileProviders.delete(key);\n                }\n            });\n        };\n        this._fileChanged = new Signal(this);\n        this._isDisposed = false;\n        this._ready = new PromiseDelegate();\n        this._signalingServers = [];\n        this._user = user;\n        //this._defaultFileBrowser = defaultFileBrowser;\n        this._trans = translator;\n        this._globalAwareness = globalAwareness;\n        //this._username = this._globalAwareness?.getLocalState()?.user.identity.name;\n        //this._username = this._globalAwareness?.getLocalState()?.username;\n        this._fileProviders = new Map();\n        this.sharedModelFactory = new SharedModelFactory(this._onCreate);\n        this.serverSettings = ServerConnection.makeSettings();\n        signalingServers.forEach((url) => {\n            if (url.startsWith('ws://') || url.startsWith('wss://') || url.startsWith('http://') || url.startsWith('https://')) {\n                // It's an absolute URL, keep it as-is.\n                this._signalingServers.push(url);\n            }\n            else {\n                // It's a Jupyter server relative URL, build the absolute URL.\n                this._signalingServers.push(URLExt.join(this.serverSettings.wsUrl, url));\n            }\n        });\n        this.name = name;\n        this._fileSystemYdoc = new Y.Doc();\n        this._fileSystemContent = this._fileSystemYdoc.getMap('content');\n        this._fileSystemProvider = new YWebrtcProvider('fileSystem', this._fileSystemYdoc, {\n            signaling: this._signalingServers,\n            awareness: this._globalAwareness || undefined\n        });\n        this._fileSystemProvider.on('synced', this._onSync);\n    }\n    getDownloadUrl(path) {\n        return new Promise(resolve => {\n            resolve('');\n        });\n    }\n    delete(path) {\n        return new Promise(resolve => {\n            resolve();\n        });\n    }\n    restoreCheckpoint(path, checkpointID) {\n        return new Promise(resolve => {\n            resolve();\n        });\n    }\n    deleteCheckpoint(path, checkpointID) {\n        return new Promise(resolve => {\n            resolve();\n        });\n    }\n    //async importFile(path: string) {\n    //  const model = await this._defaultFileBrowser.model.manager.services.contents.get(path, {content: true});\n    //  const ymap = new Y.Map();\n    //  const ytext = new Y.Text();\n    //  this._fileSystemContent.set(model.name, ymap);\n    //  ymap.set('init', new Y.Map());\n    //  ymap.set('content', ytext);\n    //  ytext.insert(0, model.content);\n    //}\n    async newUntitled(options = {}) {\n        if (options.type === 'directory') {\n            throw new Error('Cannot create directory');\n        }\n        let ext;\n        if (options.type === 'notebook') {\n            ext = 'ipynb';\n        }\n        else {\n            ext = 'txt';\n        }\n        let idx = 0;\n        let newName = '';\n        const fileSystemContent = this._fileSystemContent.toJSON();\n        while (newName === '') {\n            const _newName = `untitled${idx}.${ext}`;\n            if (_newName in fileSystemContent) {\n                idx += 1;\n            }\n            else {\n                newName = _newName;\n            }\n        }\n        const model = {\n            name: newName,\n            path: newName,\n            type: 'file',\n            writable: true,\n            created: '',\n            last_modified: '',\n            mimetype: '',\n            content: null,\n            format: null\n        };\n        const ymap = new Y.Map();\n        this._fileSystemContent.set(newName, ymap);\n        this._fileChanged.emit({\n            type: 'new',\n            oldValue: null,\n            newValue: model\n        });\n        return model;\n    }\n    async rename(path, newPath) {\n        const fileSystemContent = this._fileSystemContent.toJSON();\n        if (path in fileSystemContent) {\n            this._fileSystemContent.delete(path);\n        }\n        if (!(newPath in fileSystemContent)) {\n            const ymap = new Y.Map();\n            this._fileSystemContent.set(newPath, ymap);\n        }\n        const model = {\n            name: newPath,\n            path: newPath,\n            type: 'file',\n            writable: true,\n            created: '',\n            last_modified: '',\n            mimetype: '',\n            content: null,\n            format: null\n        };\n        return model;\n    }\n    copy(path, toDir) {\n        return new Promise(resolve => {\n            resolve(MODEL);\n        });\n    }\n    createCheckpoint(path) {\n        const model = {\n            id: '',\n            last_modified: ''\n        };\n        return new Promise(resolve => {\n            resolve(model);\n        });\n    }\n    listCheckpoints(path) {\n        return new Promise(resolve => {\n            resolve([]);\n        });\n    }\n    /**\n     * A signal emitted when a file operation takes place.\n     */\n    get fileChanged() {\n        return this._fileChanged;\n    }\n    /**\n     * Test whether the manager has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._fileProviders.forEach(p => p.dispose());\n        this._fileProviders.clear();\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param localPath: The path to the file.\n     *\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     *\n     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n     */\n    async get(localPath, options) {\n        let model;\n        await this._ready;\n        if (options && options.format && options.type) {\n            // it's a file\n            const key = `${options.format}:${options.type}:${localPath}`;\n            const provider = this._fileProviders.get(key);\n            if (provider) {\n                //await provider.ready;\n                model = {\n                    name: localPath,\n                    path: localPath,\n                    type: 'file',\n                    writable: true,\n                    created: '',\n                    last_modified: '',\n                    mimetype: '',\n                    content: null,\n                    format: null\n                };\n                return new Promise(resolve => {\n                    resolve(model);\n                });\n            }\n        }\n        // it's a directory\n        const content = [];\n        if (localPath === '') {\n            // root directory\n            this._fileSystemContent.forEach((value, key) => {\n                content.push({\n                    name: key,\n                    path: key,\n                    type: 'file',\n                    writable: true,\n                    created: '',\n                    last_modified: '',\n                    mimetype: '',\n                    content: null,\n                    format: null\n                });\n            });\n            model = {\n                name: '',\n                path: '',\n                type: 'directory',\n                writable: false,\n                created: '',\n                last_modified: '',\n                mimetype: '',\n                content,\n                format: null\n            };\n        }\n        else {\n            model = {\n                name: localPath,\n                path: localPath,\n                type: 'file',\n                writable: true,\n                created: '',\n                last_modified: '',\n                mimetype: '',\n                content: null,\n                format: null\n            };\n        }\n        return new Promise(resolve => {\n            resolve(model);\n        });\n    }\n    /**\n     * Save a file.\n     *\n     * @param localPath - The desired file path.\n     *\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the\n     *   file is saved.\n     */\n    async save(localPath, options = {}) {\n        // Check that there is a provider - it won't e.g. if the document model is not collaborative.\n        if (options.format && options.type) {\n            const key = `${options.format}:${options.type}:${localPath}`;\n            const provider = this._fileProviders.get(key);\n            if (provider) {\n                // Save is done from the backend\n                const fetchOptions = {\n                    type: options.type,\n                    format: options.format,\n                    content: false\n                };\n                return this.get(localPath, fetchOptions);\n            }\n        }\n        return new Promise(resolve => {\n            resolve(MODEL);\n        });\n        //return super.save(localPath, options);\n    }\n}\n/**\n * Yjs sharedModel factory for real-time collaboration.\n */\nclass SharedModelFactory {\n    /**\n     * Shared model factory constructor\n     *\n     * @param _onCreate Callback on new document model creation\n     */\n    constructor(_onCreate) {\n        this._onCreate = _onCreate;\n        this._documentFactories = new Map();\n    }\n    /**\n     * Register a SharedDocumentFactory.\n     *\n     * @param type Document type\n     * @param factory Document factory\n     */\n    registerDocumentFactory(type, factory) {\n        if (this._documentFactories.has(type)) {\n            throw new Error(`The content type ${type} already exists`);\n        }\n        this._documentFactories.set(type, factory);\n    }\n    /**\n     * Create a new `ISharedDocument` instance.\n     *\n     * It should return `undefined` if the factory is not able to create a `ISharedDocument`.\n     */\n    createNew(options) {\n        if (typeof options.format !== 'string') {\n            console.warn(`Only defined format are supported; got ${options.format}.`);\n            return;\n        }\n        if (this._documentFactories.has(options.contentType)) {\n            const factory = this._documentFactories.get(options.contentType);\n            const sharedModel = factory(options);\n            this._onCreate(options, sharedModel);\n            return sharedModel;\n        }\n        return;\n    }\n}\n","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module shared-docprovider\n */\nexport * from './drive';\nexport * from './provider';\nexport * from './tokens';\n","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { WebrtcProvider as YWebrtcProvider } from 'y-webrtc';\n/**\n * A class to provide Yjs synchronization over WebSocket.\n *\n * We specify custom messages that the server can interpret. For reference please look in yjs_ws_server.\n *\n */\nexport class WebrtcProvider {\n    /**\n     * Construct a new WebSocketProvider\n     *\n     * @param options The instantiation options for a WebSocketProvider\n     */\n    constructor(options) {\n        //private _onConnectionClosed = (event: any): void => {\n        //  if (event.code === 1003) {\n        //    console.error('Document provider closed:', event.reason);\n        //    showErrorMessage(this._trans.__('Document session error'), event.reason, [\n        //      Dialog.okButton()\n        //    ]);\n        //    // Dispose shared model immediately. Better break the document model,\n        //    // than overriding data on disk.\n        //    this._sharedModel.dispose();\n        //  }\n        //};\n        this._onSync = (synced) => {\n            if (synced.synced) {\n                this._ready.resolve();\n                //this._yWebrtcProvider?.off('status', this._onSync);\n            }\n        };\n        this._ready = new PromiseDelegate();\n        this._isDisposed = false;\n        this._path = options.path;\n        this._contentType = options.contentType;\n        this._format = options.format;\n        this._sharedModel = options.model;\n        this._awareness = options.model.awareness;\n        this._yWebrtcProvider = null;\n        //this._trans = options.translator;\n        this._signalingServers = options.signalingServers;\n        const user = options.user;\n        user.ready\n            .then(() => {\n            this._onUserChanged(user);\n        })\n            .catch(e => console.error(e));\n        user.userChanged.connect(this._onUserChanged, this);\n        this._connect().catch(e => console.warn(e));\n    }\n    /**\n     * Test whether the object has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A promise that resolves when the document provider is ready.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Dispose of the resources held by the object.\n     */\n    dispose() {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        //this._yWebrtcProvider?.off('connection-close', this._onConnectionClosed);\n        //this._yWebrtcProvider?.off('status', this._onSync);\n        (_a = this._yWebrtcProvider) === null || _a === void 0 ? void 0 : _a.destroy();\n        Signal.clearData(this);\n    }\n    async _connect() {\n        this._yWebrtcProvider = new YWebrtcProvider(`${this._format}:${this._contentType}:${this._path}}`, this._sharedModel.ydoc, {\n            signaling: this._signalingServers,\n            awareness: this._awareness\n        });\n        this._yWebrtcProvider.on('synced', this._onSync);\n        //this._yWebrtcProvider.on('connection-close', this._onConnectionClosed);\n    }\n    _onUserChanged(user) {\n        this._awareness.setLocalStateField('user', user.identity);\n    }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The collaborative drive.\n */\nexport const ISharedDrive = new Token('@jupyter/shared-drive-extension:ISharedDrive');\n"],"names":[],"sourceRoot":""}