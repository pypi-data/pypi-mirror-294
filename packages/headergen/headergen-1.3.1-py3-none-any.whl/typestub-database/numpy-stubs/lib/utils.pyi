from ast import AST
from collections.abc import Mapping, Sequence
from numpy import generic as generic, ndarray as ndarray
from typing import Any, Protocol, overload

class _SupportsWrite(Protocol[_T_contra]):
    def write(self, s: _T_contra) -> Any: ...

class _Deprecate:
    old_name: None | str
    new_name: None | str
    message: None | str
    def __init__(self, old_name: None | str = ..., new_name: None | str = ..., message: None | str = ...) -> None: ...
    def __call__(self, func: _FuncType) -> _FuncType: ...

def get_include() -> str: ...
@overload
def deprecate(*, old_name: None | str = ..., new_name: None | str = ..., message: None | str = ...) -> _Deprecate: ...
@overload
def deprecate(func: _FuncType, old_name: None | str = ..., new_name: None | str = ..., message: None | str = ...) -> _FuncType: ...
def deprecate_with_doc(msg: None | str) -> _Deprecate: ...
def byte_bounds(a: generic | ndarray[Any, Any]) -> tuple[int, int]: ...
def who(vardict: None | Mapping[str, ndarray[Any, Any]] = ...) -> None: ...
def info(object: object = ..., maxwidth: int = ..., output: None | _SupportsWrite[str] = ..., toplevel: str = ...) -> None: ...
def source(object: object, output: None | _SupportsWrite[str] = ...) -> None: ...
def lookfor(what: str, module: None | str | Sequence[str] = ..., import_modules: bool = ..., regenerate: bool = ..., output: None | _SupportsWrite[str] = ...) -> None: ...
def safe_eval(source: str | AST) -> Any: ...
