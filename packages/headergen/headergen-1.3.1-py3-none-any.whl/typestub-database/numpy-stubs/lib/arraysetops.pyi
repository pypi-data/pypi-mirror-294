from numpy import bool_ as bool_, byte as byte, bytes_ as bytes_, cdouble as cdouble, clongdouble as clongdouble, csingle as csingle, datetime64 as datetime64, double as double, generic as generic, half as half, int8 as int8, int_ as int_, intc as intc, intp as intp, longdouble as longdouble, longlong as longlong, number as number, object_ as object_, short as short, single as single, str_ as str_, timedelta64 as timedelta64, ubyte as ubyte, uint as uint, uintc as uintc, ulonglong as ulonglong, ushort as ushort, void as void
from numpy._typing import ArrayLike as ArrayLike, NDArray as NDArray, _ArrayLike, _ArrayLikeBool_co, _ArrayLikeDT64_co, _ArrayLikeNumber_co, _ArrayLikeObject_co, _ArrayLikeTD64_co
from typing import Any, Literal as L, SupportsIndex, overload

@overload
def ediff1d(ary: _ArrayLikeBool_co, to_end: None | ArrayLike = ..., to_begin: None | ArrayLike = ...) -> NDArray[int8]: ...
@overload
def ediff1d(ary: _ArrayLike[_NumberType], to_end: None | ArrayLike = ..., to_begin: None | ArrayLike = ...) -> NDArray[_NumberType]: ...
@overload
def ediff1d(ary: _ArrayLikeNumber_co, to_end: None | ArrayLike = ..., to_begin: None | ArrayLike = ...) -> NDArray[Any]: ...
@overload
def ediff1d(ary: _ArrayLikeDT64_co | _ArrayLikeTD64_co, to_end: None | ArrayLike = ..., to_begin: None | ArrayLike = ...) -> NDArray[timedelta64]: ...
@overload
def ediff1d(ary: _ArrayLikeObject_co, to_end: None | ArrayLike = ..., to_begin: None | ArrayLike = ...) -> NDArray[object_]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[False] = ..., return_inverse: L[False] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> NDArray[_SCT]: ...
@overload
def unique(ar: ArrayLike, return_index: L[False] = ..., return_inverse: L[False] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> NDArray[Any]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[True] = ..., return_inverse: L[False] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[True] = ..., return_inverse: L[False] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp]]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[False] = ..., return_inverse: L[True] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[False] = ..., return_inverse: L[True] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp]]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[False] = ..., return_inverse: L[False] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[False] = ..., return_inverse: L[False] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp]]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[True] = ..., return_inverse: L[True] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[True] = ..., return_inverse: L[True] = ..., return_counts: L[False] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[True] = ..., return_inverse: L[False] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[True] = ..., return_inverse: L[False] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[False] = ..., return_inverse: L[True] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[False] = ..., return_inverse: L[True] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: _ArrayLike[_SCT], return_index: L[True] = ..., return_inverse: L[True] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[_SCT], NDArray[intp], NDArray[intp], NDArray[intp]]: ...
@overload
def unique(ar: ArrayLike, return_index: L[True] = ..., return_inverse: L[True] = ..., return_counts: L[True] = ..., axis: None | SupportsIndex = ..., *, equal_nan: bool = ...) -> tuple[NDArray[Any], NDArray[intp], NDArray[intp], NDArray[intp]]: ...
@overload
def intersect1d(ar1: _ArrayLike[_SCTNoCast], ar2: _ArrayLike[_SCTNoCast], assume_unique: bool = ..., return_indices: L[False] = ...) -> NDArray[_SCTNoCast]: ...
@overload
def intersect1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = ..., return_indices: L[False] = ...) -> NDArray[Any]: ...
@overload
def intersect1d(ar1: _ArrayLike[_SCTNoCast], ar2: _ArrayLike[_SCTNoCast], assume_unique: bool = ..., return_indices: L[True] = ...) -> tuple[NDArray[_SCTNoCast], NDArray[intp], NDArray[intp]]: ...
@overload
def intersect1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = ..., return_indices: L[True] = ...) -> tuple[NDArray[Any], NDArray[intp], NDArray[intp]]: ...
@overload
def setxor1d(ar1: _ArrayLike[_SCTNoCast], ar2: _ArrayLike[_SCTNoCast], assume_unique: bool = ...) -> NDArray[_SCTNoCast]: ...
@overload
def setxor1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = ...) -> NDArray[Any]: ...
def in1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = ..., invert: bool = ...) -> NDArray[bool_]: ...
def isin(element: ArrayLike, test_elements: ArrayLike, assume_unique: bool = ..., invert: bool = ...) -> NDArray[bool_]: ...
@overload
def union1d(ar1: _ArrayLike[_SCTNoCast], ar2: _ArrayLike[_SCTNoCast]) -> NDArray[_SCTNoCast]: ...
@overload
def union1d(ar1: ArrayLike, ar2: ArrayLike) -> NDArray[Any]: ...
@overload
def setdiff1d(ar1: _ArrayLike[_SCTNoCast], ar2: _ArrayLike[_SCTNoCast], assume_unique: bool = ...) -> NDArray[_SCTNoCast]: ...
@overload
def setdiff1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = ...) -> NDArray[Any]: ...
