! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_RANDOM
USE ISO_FORTRAN_ENV , ONLY : REAL32 , INT64 , INT32
USE ISO_C_BINDING , ONLY : LT => C_BOOL
USE PCG32_MODULE , ONLY : PCG_INT => INT64 , PCG32_SEED_RANDOM , PCG32_RANDOM , PCG32_RANDOM_REAL , PCG32_BOUNDED_RANDOM
  IMPLICIT NONE


CONTAINS


  ! Getter and setter for ZERO.
  SUBROUTINE RANDOM_GET_ZERO(ZERO_LOCAL) BIND(C)
    USE RANDOM, ONLY: ZERO
    INTEGER(KIND=INT64) :: ZERO_LOCAL
    ZERO_LOCAL = ZERO
  END SUBROUTINE RANDOM_GET_ZERO

  ! Getter and setter for ONE.
  SUBROUTINE RANDOM_GET_ONE(ONE_LOCAL) BIND(C)
    USE RANDOM, ONLY: ONE
    INTEGER(KIND=INT64) :: ONE_LOCAL
    ONE_LOCAL = ONE
  END SUBROUTINE RANDOM_GET_ONE

  ! Getter and setter for TWO.
  SUBROUTINE RANDOM_GET_TWO(TWO_LOCAL) BIND(C)
    USE RANDOM, ONLY: TWO
    INTEGER(KIND=INT64) :: TWO_LOCAL
    TWO_LOCAL = TWO
  END SUBROUTINE RANDOM_GET_TWO

  ! Getter and setter for FOUR.
  SUBROUTINE RANDOM_GET_FOUR(FOUR_LOCAL) BIND(C)
    USE RANDOM, ONLY: FOUR
    INTEGER(KIND=INT64) :: FOUR_LOCAL
    FOUR_LOCAL = FOUR
  END SUBROUTINE RANDOM_GET_FOUR

  ! Getter and setter for PI.
  SUBROUTINE RANDOM_GET_PI(PI_LOCAL) BIND(C)
    USE RANDOM, ONLY: PI
    REAL(KIND=REAL32) :: PI_LOCAL
    PI_LOCAL = PI
  END SUBROUTINE RANDOM_GET_PI

  ! Getter and setter for RIGHT_32.
  SUBROUTINE RANDOM_GET_RIGHT_32(RIGHT_32_LOCAL) BIND(C)
    USE RANDOM, ONLY: RIGHT_32
    INTEGER(KIND=INT64) :: RIGHT_32_LOCAL
    RIGHT_32_LOCAL = RIGHT_32
  END SUBROUTINE RANDOM_GET_RIGHT_32

  
  SUBROUTINE C_SEED_RANDOM(SEED_PRESENT, SEED) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: SEED_RANDOM
    IMPLICIT NONE
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: SEED_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: SEED
  
    IF (SEED_PRESENT) THEN
      CALL SEED_RANDOM(SEED=SEED)
    ELSE
      CALL SEED_RANDOM()
    END IF
  END SUBROUTINE C_SEED_RANDOM
  

  
  SUBROUTINE C_RANDOM_REAL(R_PRESENT, R_DIM_1, R, S_PRESENT, S, V_PRESENT, V) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: RANDOM_REAL
    IMPLICIT NONE
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: R_PRESENT
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: R_DIM_1
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(R_DIM_1) :: R
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: S_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: S
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: V_PRESENT
    REAL(KIND=REAL32), INTENT(OUT) :: V
  
    IF (R_PRESENT) THEN
      IF (S_PRESENT) THEN
        IF (V_PRESENT) THEN
          CALL RANDOM_REAL(R=R, S=S, V=V)
        ELSE
          CALL RANDOM_REAL(R=R, S=S)
        END IF
      ELSE
        IF (V_PRESENT) THEN
          CALL RANDOM_REAL(R=R, V=V)
        ELSE
          CALL RANDOM_REAL(R=R)
        END IF
      END IF
    ELSE
      IF (S_PRESENT) THEN
        IF (V_PRESENT) THEN
          CALL RANDOM_REAL(S=S, V=V)
        ELSE
          CALL RANDOM_REAL(S=S)
        END IF
      ELSE
        IF (V_PRESENT) THEN
          CALL RANDOM_REAL(V=V)
        ELSE
          CALL RANDOM_REAL()
        END IF
      END IF
    END IF
  END SUBROUTINE C_RANDOM_REAL
  

  
  SUBROUTINE C_RANDOM_UNIT_VECTORS(COLUMN_VECTORS_DIM_1, COLUMN_VECTORS_DIM_2, COLUMN_VECTORS) BIND(C)
    USE RANDOM, ONLY: RANDOM_UNIT_VECTORS
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: COLUMN_VECTORS_DIM_1
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: COLUMN_VECTORS_DIM_2
    REAL(KIND=REAL32), INTENT(OUT), DIMENSION(COLUMN_VECTORS_DIM_1,COLUMN_VECTORS_DIM_2) :: COLUMN_VECTORS
  
    CALL RANDOM_UNIT_VECTORS(COLUMN_VECTORS)
  END SUBROUTINE C_RANDOM_UNIT_VECTORS
  

  
  SUBROUTINE C_INITIALIZE_ITERATOR(I_LIMIT, I_NEXT, I_MULT, I_STEP, I_MOD, I_ITER, SEED_PRESENT, SEED) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: INITIALIZE_ITERATOR
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: I_LIMIT
    INTEGER(KIND=INT64), INTENT(OUT) :: I_NEXT
    INTEGER(KIND=INT64), INTENT(OUT) :: I_MULT
    INTEGER(KIND=INT64), INTENT(OUT) :: I_STEP
    INTEGER(KIND=INT64), INTENT(OUT) :: I_MOD
    INTEGER(KIND=INT64), INTENT(OUT) :: I_ITER
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: SEED_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: SEED
  
    IF (SEED_PRESENT) THEN
      CALL INITIALIZE_ITERATOR(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD, I_ITER=I_ITER, SEED=SEED)
    ELSE
      CALL INITIALIZE_ITERATOR(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD, I_ITER=I_ITER)
    END IF
  END SUBROUTINE C_INITIALIZE_ITERATOR
  

  
  SUBROUTINE C_INDEX_TO_PAIR(NUM_ELEMENTS, I, PAIR1, PAIR2) BIND(C)
    USE RANDOM, ONLY: INDEX_TO_PAIR
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: NUM_ELEMENTS
    INTEGER(KIND=INT64), INTENT(IN) :: I
    INTEGER(KIND=INT64), INTENT(OUT) :: PAIR1
    INTEGER(KIND=INT64), INTENT(OUT) :: PAIR2
  
    CALL INDEX_TO_PAIR(NUM_ELEMENTS, I, PAIR1, PAIR2)
  END SUBROUTINE C_INDEX_TO_PAIR
  

  
  SUBROUTINE C_PAIR_TO_INDEX(NUM_ELEMENTS, PAIR1, PAIR2, I) BIND(C)
    USE RANDOM, ONLY: PAIR_TO_INDEX
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: NUM_ELEMENTS
    INTEGER(KIND=INT64), INTENT(IN) :: PAIR1
    INTEGER(KIND=INT64), INTENT(IN) :: PAIR2
    INTEGER(KIND=INT64), INTENT(OUT) :: I
  
    CALL PAIR_TO_INDEX(NUM_ELEMENTS, PAIR1, PAIR2, I)
  END SUBROUTINE C_PAIR_TO_INDEX
  

  
  SUBROUTINE C_RANDOM_INTEGER(MAX_VALUE_PRESENT, MAX_VALUE, RANDOM_INT) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: RANDOM_INTEGER
    IMPLICIT NONE
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: MAX_VALUE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: MAX_VALUE
    INTEGER(KIND=INT64) :: RANDOM_INT
  
    IF (MAX_VALUE_PRESENT) THEN
      RANDOM_INT = RANDOM_INTEGER(MAX_VALUE=MAX_VALUE)
    ELSE
      RANDOM_INT = RANDOM_INTEGER()
    END IF
  END SUBROUTINE C_RANDOM_INTEGER
  

  
  SUBROUTINE C_GET_NEXT_INDEX(I_LIMIT, I_NEXT, I_MULT, I_STEP, I_MOD, I_ITER, RESHUFFLE_PRESENT, RESHUFFLE, NEXT_I) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE RANDOM, ONLY: GET_NEXT_INDEX
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: I_LIMIT
    INTEGER(KIND=INT64), INTENT(INOUT) :: I_NEXT
    INTEGER(KIND=INT64), INTENT(INOUT) :: I_MULT
    INTEGER(KIND=INT64), INTENT(INOUT) :: I_STEP
    INTEGER(KIND=INT64), INTENT(INOUT) :: I_MOD
    INTEGER(KIND=INT64), INTENT(INOUT) :: I_ITER
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: RESHUFFLE_PRESENT
    LOGICAL(KIND=LT), INTENT(IN) :: RESHUFFLE
    INTEGER(KIND=INT64) :: NEXT_I
  
    IF (RESHUFFLE_PRESENT) THEN
      NEXT_I = GET_NEXT_INDEX(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD, I_ITER=I_ITER, RESHUFFLE=R&
&ESHUFFLE)
    ELSE
      NEXT_I = GET_NEXT_INDEX(I_LIMIT=I_LIMIT, I_NEXT=I_NEXT, I_MULT=I_MULT, I_STEP=I_STEP, I_MOD=I_MOD, I_ITER=I_ITER)
    END IF
  END SUBROUTINE C_GET_NEXT_INDEX
  
END MODULE C_RANDOM

