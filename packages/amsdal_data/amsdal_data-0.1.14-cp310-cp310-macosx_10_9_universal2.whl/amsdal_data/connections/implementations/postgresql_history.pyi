import psycopg2._psycopg
from _typeshed import Incomplete
from amsdal_data.connections.errors import AmsdalConnectionError as AmsdalConnectionError
from amsdal_data.connections.historical_base import HistoricalConnectionBase as HistoricalConnectionBase
from amsdal_data.connections.implementations.mixins.sql_history_conection_mixin import SqlHistoryConnectionMixin as SqlHistoryConnectionMixin
from amsdal_data.connections.implementations.mixins.sqlite_statements_mixin import ADDRESS_FIELD as ADDRESS_FIELD, METADATA_FIELD as METADATA_FIELD, METADATA_TABLE_ALIAS as METADATA_TABLE_ALIAS, MODEL_TABLE_ALIAS as MODEL_TABLE_ALIAS, NoValue as NoValue, SqlOperatorTemplate as SqlOperatorTemplate
from amsdal_data.connections.utils import sort_items as sort_items
from amsdal_data.table_schemas.base import TableSchemaServiceBase as TableSchemaServiceBase
from amsdal_data.table_schemas.constants import PRIMARY_PARTITION_KEY as PRIMARY_PARTITION_KEY, SECONDARY_PARTITION_KEY as SECONDARY_PARTITION_KEY
from amsdal_utils.models.data_models.address import Address as Address
from amsdal_utils.query.data_models.order_by import OrderBy as OrderBy
from amsdal_utils.query.data_models.paginator import CursorPaginator, NumberPaginator
from amsdal_utils.query.data_models.query_specifier import QuerySpecifier as QuerySpecifier
from amsdal_utils.query.enums import Lookup
from amsdal_utils.query.utils import Q as Q
from typing import Any

logger: Incomplete
METADATA_SELECT_STATEMENT: str
METADATA_SELECT_FIELD: Incomplete
sql_operator_map: dict[Lookup, SqlOperatorTemplate]

class PostgresHistoricalConnection(SqlHistoryConnectionMixin, HistoricalConnectionBase):
    TABLE_SEPARATOR: str
    COLUMN_SEPARATOR: str
    SQL_OPERATOR_MAP = sql_operator_map
    def _savepoint_name(self) -> str: ...
    _is_revert_enabled: Incomplete
    _revert_data: Incomplete
    _savepoints: Incomplete
    _connection: Incomplete
    def __init__(self, *, is_revert_supported: bool = True) -> None: ...
    @property
    def table_schema_manager(self) -> TableSchemaServiceBase: ...
    def _default_envs(self) -> dict[str, Any]: ...
    def connect(self, dsn: str | None = None, **kwargs: Any) -> None:
        """
        Connects to the PostgreSQL database. Raises an AmsdalConnectionError if the connection is already established.
        :param dsn: the path to the database
        :type dsn: str | None
        :param kwargs: the connection parameters
        :type kwargs: Any

        :return: None
        """
    @property
    def is_connected(self) -> bool: ...
    @property
    def is_alive(self) -> bool: ...
    def disconnect(self) -> None: ...
    def _describe_table(self, table_name: str) -> dict[str, str]: ...
    def _build_insert_statement(self, table_name: str, data: dict[str, Any]) -> tuple[str, tuple[Any, ...]]: ...
    def _build_bulk_insert_statement(self, table_name: str, data: list[dict[str, Any]]) -> tuple[str, tuple[Any, ...]]: ...
    def _build_delete_statement(self, table_name: str, data: dict[str, Any]) -> tuple[str, tuple[Any, ...]]: ...
    def process_value_before_insert(self, value: Any, data_type: str) -> Any: ...
    def put(self, address: Address, data: dict[str, Any]) -> None: ...
    def bulk_put(self, data: list[tuple[Address, dict[str, Any]]]) -> None: ...
    def begin(self) -> None: ...
    def commit(self) -> None: ...
    def revert(self) -> None: ...
    def rollback(self) -> None: ...
    def on_transaction_complete(self) -> None:
        """Transaction is completed successfully. Clear the revert data."""
    def query(self, address: Address, query_specifier: QuerySpecifier | None = None, conditions: Q | None = None, pagination: NumberPaginator | CursorPaginator | None = None, order_by: list[OrderBy] | None = None) -> list[dict[str, Any]]: ...
    @staticmethod
    def _paginate_items(items: list[dict[str, Any]], pagination: NumberPaginator | CursorPaginator | None) -> list[dict[str, Any]]: ...
    def execute(self, query: str, *args: Any) -> psycopg2._psycopg.cursor: ...
    def count(self, address: Address, conditions: Q | None = None) -> int: ...
    def prepare_connection(self) -> None: ...
    def _add_revert_data(self, address: Address, data: dict[str, Any]) -> None: ...
    def _delete(self, address: Address) -> None: ...
    def _query(self, table_name: str, query_specifier: QuerySpecifier | None, conditions: Q | None, pagination: NumberPaginator | CursorPaginator | None, order_by: list[OrderBy] | None) -> list[dict[str, Any]]: ...
    def _nested_filter_statement(self, table_name: str, field_name: str, nested_fields: str, sql_operator_template: SqlOperatorTemplate, value: Any, value_type: Any, *, is_internal_table: bool = False, use_internal_meta_tables: bool = False) -> tuple[str, Any]: ...
    def _resolve_nested_field_name(self, table_name: str, field_name: str, nested_fields: str, *, value_type: Any = ..., is_internal_table: bool = False, use_internal_meta_tables: bool = False) -> str: ...
    def _select_with_internal_meta_statement(self, table_name: str, select_only: str, conditions: Q | None = None, pagination: NumberPaginator | CursorPaginator | None = None, order_by: list[OrderBy] | None = None) -> tuple[str, list[Any]]: ...
    def _build_group_by_statement(self, table_name: str, order_by: list[OrderBy] | None, *, is_internal_table: bool = False, use_internal_meta_tables: bool = False) -> str: ...
    def _build_select_statement(self, table_name: str, query_specifier: QuerySpecifier | None = None, conditions: Q | None = None, pagination: NumberPaginator | CursorPaginator | None = None, order_by: list[OrderBy] | None = None, *, use_internal_meta_tables: bool = False) -> tuple[str, list[Any]]: ...
