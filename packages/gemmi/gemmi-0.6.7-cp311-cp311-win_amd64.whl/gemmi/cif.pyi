"""
CIF file format
"""
from __future__ import annotations
import typing
__all__ = ['Block', 'Column', 'Ddl', 'Document', 'Item', 'Loop', 'Style', 'Table', 'WriteOptions', 'as_int', 'as_number', 'as_string', 'is_null', 'quote', 'quote_list', 'read', 'read_file', 'read_mmjson', 'read_string']
class Block:
    name: str
    def __getitem__(self, index: int) -> Item:
        ...
    def __init__(self, arg0: str) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Item]:
        ...
    def __repr__(self) -> str:
        ...
    def add_item(self, item: Item, pos: int = -1) -> Item:
        ...
    @typing.overload
    def as_string(self, options: WriteOptions = ...) -> str:
        """
        Returns a string in CIF format.
        """
    @typing.overload
    def as_string(self, style: Style) -> str:
        ...
    @typing.overload
    def find(self, prefix: str, tags: list[str]) -> Table:
        ...
    @typing.overload
    def find(self, tags: list[str]) -> Table:
        ...
    def find_frame(self, name: str) -> Block:
        ...
    def find_loop(self, tag: str) -> Column:
        ...
    def find_loop_item(self, tag: str) -> Item:
        ...
    def find_mmcif_category(self, category: str) -> Table:
        """
        Returns Table with all items in the category.
        """
    def find_or_add(self, prefix: str, tags: list[str]) -> Table:
        ...
    def find_pair(self, tag: str) -> typing.Any:
        ...
    def find_pair_item(self, tag: str) -> Item:
        ...
    def find_value(self, tag: str) -> str:
        ...
    def find_values(self, tag: str) -> Column:
        ...
    def get_index(self, tag: str) -> int:
        ...
    def get_mmcif_category(self, name: str, raw: bool = False) -> dict:
        ...
    def get_mmcif_category_names(self) -> list[str]:
        """
        For mmCIF files only. Returns list of all category prefixes (_x.)
        """
    def init_loop(self, prefix: str, tags: list[str]) -> Loop:
        ...
    def init_mmcif_loop(self, cat: str, tags: list[str]) -> Loop:
        ...
    def item_as_table(self, arg0: Item) -> Table:
        ...
    def move_item(self, old_pos: int, new_pos: int) -> None:
        ...
    def set_mmcif_category(self, name: str, data: dict, raw: bool = False) -> None:
        ...
    def set_pair(self, tag: str, value: str) -> None:
        ...
    def set_pairs(self, prefix: str, data: dict, raw: bool = False) -> None:
        ...
    @typing.overload
    def write_file(self, filename: str, options: WriteOptions = ...) -> None:
        """
        Write data to a CIF file.
        """
    @typing.overload
    def write_file(self, filename: str, style: Style) -> None:
        ...
class Column:
    tag: str
    def __bool__(self) -> bool:
        ...
    def __getitem__(self, arg0: int) -> str:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator[str]:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: str) -> None:
        ...
    def erase(self) -> None:
        ...
    def get_loop(self) -> Loop:
        ...
    def str(self, index: int) -> str:
        ...
class Ddl:
    def __init__(self, print_unknown_tags: bool = True, use_regex: bool = True, use_context: bool = True, use_linked_groups: bool = True, use_mandatory: bool = True, use_unique_keys: bool = True) -> None:
        ...
    def read_ddl_file(self, path: str) -> str:
        ...
    def validate_cif(self, arg0: Document) -> str:
        ...
class Document:
    source: str
    def __contains__(self, name: str) -> bool:
        ...
    def __delitem__(self, index: int) -> None:
        ...
    @typing.overload
    def __getitem__(self, name: str) -> Block:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Block:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Block]:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def add_copied_block(self, block: Block, pos: int = -1) -> Block:
        ...
    def add_new_block(self, name: str, pos: int = -1) -> Block:
        ...
    def as_json(self, mmjson: bool = False, lowercase_names: bool = True) -> str:
        """
        Returns JSON representation in a string.
        """
    @typing.overload
    def as_string(self, options: WriteOptions = ...) -> str:
        """
        Returns a string in CIF format.
        """
    @typing.overload
    def as_string(self, style: Style) -> str:
        ...
    def check_for_duplicates(self) -> None:
        ...
    def check_for_missing_values(self) -> None:
        ...
    def clear(self) -> None:
        ...
    def find_block(self, name: str) -> Block:
        ...
    def parse_file(self, arg0: str) -> None:
        ...
    def parse_string(self, arg0: str) -> None:
        ...
    def sole_block(self) -> Block:
        """
        Returns the only block if there is exactly one
        """
    @typing.overload
    def write_file(self, filename: str, options: WriteOptions = ...) -> None:
        """
        Write data to a CIF file.
        """
    @typing.overload
    def write_file(self, filename: str, style: Style) -> None:
        ...
class Item:
    def erase(self) -> None:
        ...
    @property
    def frame(self) -> Block:
        ...
    @property
    def line_number(self) -> int:
        ...
    @property
    def loop(self) -> Loop:
        ...
    @property
    def pair(self) -> typing.Any:
        ...
class Loop:
    def __getitem__(self, arg0: tuple[int, int]) -> str:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: tuple[int, int], arg1: str) -> None:
        ...
    def add_columns(self, column_names: list[str], value: str, pos: int = -1) -> None:
        ...
    def add_row(self, new_values: list[str], pos: int = -1) -> None:
        ...
    def length(self) -> int:
        """
        Returns number of rows
        """
    def remove_column(self, arg0: str) -> None:
        ...
    def set_all_values(self, columns: list[list[str]]) -> None:
        ...
    def width(self) -> int:
        """
        Returns number of columns
        """
    @property
    def tags(self) -> list[str]:
        ...
    @property
    def values(self) -> list[str]:
        ...
class Style:
    """
    Members:
    
      Simple
    
      NoBlankLines
    
      PreferPairs
    
      Pdbx
    
      Indent35
    
      Aligned
    """
    Aligned: typing.ClassVar[Style]  # value = <Style.Aligned: 5>
    Indent35: typing.ClassVar[Style]  # value = <Style.Indent35: 4>
    NoBlankLines: typing.ClassVar[Style]  # value = <Style.NoBlankLines: 1>
    Pdbx: typing.ClassVar[Style]  # value = <Style.Pdbx: 3>
    PreferPairs: typing.ClassVar[Style]  # value = <Style.PreferPairs: 2>
    Simple: typing.ClassVar[Style]  # value = <Style.Simple: 0>
    __members__: typing.ClassVar[dict[str, Style]]  # value = {'Simple': <Style.Simple: 0>, 'NoBlankLines': <Style.NoBlankLines: 1>, 'PreferPairs': <Style.PreferPairs: 2>, 'Pdbx': <Style.Pdbx: 3>, 'Indent35': <Style.Indent35: 4>, 'Aligned': <Style.Aligned: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Table:
    class Row:
        @typing.overload
        def __getitem__(self, arg0: int) -> str:
            ...
        @typing.overload
        def __getitem__(self, arg0: str) -> str:
            ...
        def __iter__(self) -> typing.Iterator[str]:
            ...
        def __len__(self) -> int:
            ...
        def __repr__(self) -> str:
            ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: str) -> None:
            ...
        @typing.overload
        def __setitem__(self, arg0: str, arg1: str) -> None:
            ...
        def get(self, index: int) -> str:
            ...
        def has(self, index: int) -> bool:
            ...
        def str(self, arg0: int) -> str:
            ...
        @property
        def row_index(self) -> int:
            ...
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        ...
    def __getitem__(self, arg0: int) -> Table.Row:
        ...
    def __iter__(self) -> typing.Iterator[Table.Row]:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def append_row(self, new_values: list[str]) -> None:
        ...
    def column(self, n: int) -> Column:
        ...
    def ensure_loop(self) -> None:
        ...
    def erase(self) -> None:
        ...
    def find_column(self, tag: str) -> Column:
        ...
    def find_row(self, arg0: str) -> Table.Row:
        ...
    def get_prefix(self) -> str:
        ...
    def has_column(self, arg0: int) -> bool:
        ...
    def move_row(self, old_pos: int, new_pos: int) -> None:
        ...
    def remove_row(self, row_index: int) -> None:
        ...
    def width(self) -> int:
        ...
    @property
    def loop(self) -> Loop:
        ...
    @property
    def prefix_length(self) -> int:
        ...
    @property
    def tags(self) -> Table.Row:
        ...
class WriteOptions:
    align_loops: int
    align_pairs: int
    compact: bool
    misuse_hash: bool
    prefer_pairs: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
@typing.overload
def as_int(value: str) -> int:
    """
    Returns int number from string value.
    """
@typing.overload
def as_int(value: str, default: int) -> int:
    """
    Returns int number from string value or the second arg if null.
    """
def as_number(value: str, default: float = ...) -> float:
    """
    Returns float number from string
    """
def as_string(value: str) -> str:
    """
    Get string content (no quotes) from raw string.
    """
def is_null(value: str) -> bool:
    ...
def quote(string: str) -> str:
    ...
def quote_list(arg0: list) -> list[str]:
    ...
def read(filename: str) -> Document:
    """
    Reads normal or gzipped CIF file.
    """
def read_file(filename: str) -> Document:
    """
    Reads a CIF file copying data into Document.
    """
def read_mmjson(filename: str) -> Document:
    """
    Reads normal or gzipped mmJSON file.
    """
def read_string(data: str) -> Document:
    """
    Reads a string as a CIF file.
    """
