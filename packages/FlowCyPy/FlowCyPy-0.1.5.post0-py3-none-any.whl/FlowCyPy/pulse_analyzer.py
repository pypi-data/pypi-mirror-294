import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, peak_widths
from MPSPlots.styles import mps
from FlowCyPy import Peak


class PulseAnalyzer:
    """
    A class to analyze pulse signals generated by a flow cytometer, extracting features
    such as pulse height, width, and area from the signal.

    Attributes
    ----------
    time : numpy.ndarray
        The time axis corresponding to the signal.
    signal : numpy.ndarray
        The raw signal to be analyzed (e.g., FSC or SSC signal).
    height_threshold : float
        The minimum height required for a peak to be considered significant.
    peaks : list of Peak
        A list of Peak objects representing the detected peaks.

    Methods
    -------
    find_peaks():
        Detects peaks in the raw signal based on the height threshold.
    calculate_widths():
        Calculates the widths of the detected peaks at half maximum.
    calculate_areas():
        Calculates the areas under the detected peaks.
    display_features():
        Displays the extracted features such as heights, widths, and areas for the first few peaks.
    plot():
        Plots the signal along with detected peaks, widths, and areas on a time axis.
    """

    def __init__(self, time: np.ndarray, signal: np.ndarray, height_threshold: float) -> None:
        """
        Initializes the PulseAnalyzer object with the time, signal, and a height threshold for peak detection.

        Parameters
        ----------
        time : numpy.ndarray
            The time axis corresponding to the signal.
        signal : numpy.ndarray
            The raw signal to be analyzed (e.g., FSC or SSC signal).
        height_threshold : float
            The minimum height required for a peak to be considered significant.
        """
        self.time = time
        self.signal = signal
        self.height_threshold = height_threshold
        self.peaks = []  # List of detected peaks

    def find_peaks(self) -> None:
        """
        Detects significant peaks in the signal based on the height threshold.
        """
        peak_indices, _ = find_peaks(self.signal, height=self.height_threshold)
        peak_heights = self.signal[peak_indices]

        self.peaks = [Peak(time=self.time[idx], height=height, width=None) for idx, height in zip(peak_indices, peak_heights)]

    def calculate_widths(self) -> None:
        """
        Calculates the widths of the detected peaks at half maximum height.
        Widths are calculated only after peaks are detected using the `find_peaks` method.
        """
        if not self.peaks:
            raise ValueError("No peaks detected. Run 'find_peaks()' before calculating widths.")

        peak_indices = [np.where(self.time == peak.time)[0][0] for peak in self.peaks]
        widths = peak_widths(self.signal, peak_indices, rel_height=0.5)[0]

        dt = self.time[1] - self.time[0]  # Time step
        for peak, width in zip(self.peaks, widths):
            peak.width = width * dt

    def calculate_areas(self) -> None:
        """
        Calculates the areas under the detected peaks using the signal data.
        Requires that peak widths have already been calculated.
        """
        if not self.peaks:
            raise ValueError("No peaks detected. Run 'find_peaks()' and 'calculate_widths()' before calculating areas.")

        for peak in self.peaks:
            if peak.width is not None:
                peak.calculate_area(self.signal, self.time)

    def display_features(self) -> None:
        """
        Displays the extracted features of the detected peaks, including height, width, and area
        in a tabular format using the tabulate library.
        """
        from tabulate import tabulate
        # Header for the table
        headers = ["Peak", "Time [s]", "Height", "Width", "Area"]

        # Collect peak data
        table = []
        for i, peak in enumerate(self.peaks):
            table.append([
                i + 1,  # Peak number
                f"{peak.time:.3f}",  # Time
                f"{peak.height:.3f}",  # Height
                f"{peak.width:.3f}" if peak.width is not None else "Not calculated",  # Width
                f"{peak.area:.3f}" if peak.area is not None else "Not calculated"  # Area
            ])

        # Display the table
        print(f"Number of detected peaks: {len(self.peaks)}")
        print(tabulate(table, headers=headers, tablefmt="grid"))

    def _add_to_ax(self, ax: plt.Axes) -> None:
        """
        Adds the signal, detected peaks, and peak widths to the provided matplotlib axis.

        Parameters
        ----------
        ax : plt.Axes
            Matplotlib axis where the signal and peaks will be plotted.
        """
        ax.plot(self.time, self.signal, label='Signal')

        for peak in self.peaks:
            ax.plot(peak.time, peak.height, 'x', label='Peaks')
            if peak.width:
                ax.hlines(y=peak.height / 2, xmin=peak.time - peak.width / 2, xmax=peak.time + peak.width / 2, colors='r', label='Width at Half-Max')

        # Deduplicate legend labels
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        ax.legend(by_label.values(), by_label.keys())

        ax.set(
            title='Pulse Analysis',
            xlabel='Time [seconds]',
            ylabel='Signal Amplitude'
        )

    def plot(self) -> None:
        """
        Plots the signal with detected peaks and widths at half-maximum, if available.
        """
        with plt.style.context(mps):
            fig, ax = plt.subplots(1, 1, figsize=(10, 5))
            self._add_to_ax(ax=ax)
            plt.show()
