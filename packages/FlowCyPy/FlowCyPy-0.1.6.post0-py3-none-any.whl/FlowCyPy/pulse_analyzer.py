import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, peak_widths
from MPSPlots.styles import mps
from FlowCyPy import Peak


class PulseAnalyzer:
    """
    A class to analyze pulse signals generated by a flow cytometer, extracting features
    such as pulse height, width, and area from the signal.

    Attributes
    ----------
    detector : Detector
        The detector containing the time and measure signal
    height_threshold : float
        The minimum height required for a peak to be considered significant.
    peaks : list of Peak
        A list of Peak objects representing the detected peaks.

    Methods
    -------
    find_peaks():
        Detects peaks in the raw signal based on the height threshold.
    calculate_widths():
        Calculates the widths of the detected peaks at half maximum.
    calculate_areas():
        Calculates the areas under the detected peaks.
    display_features():
        Displays the extracted features such as heights, widths, and areas for the first few peaks.
    plot():
        Plots the signal along with detected peaks, widths, and areas on a time axis.
    """

    def __init__(self, detector, height_threshold: float) -> None:
        """
        Initializes the PulseAnalyzer object with the time, signal, and a height threshold for peak detection.

        Parameters
        ----------
        time : numpy.ndarray
            The time axis corresponding to the signal.
        signal : numpy.ndarray
            The raw signal to be analyzed (e.g., FSC or SSC signal).
        height_threshold : float
            The minimum height required for a peak to be considered significant.
        """
        self.detector = detector
        self.height_threshold = height_threshold
        self.peaks = []  # List of detected peaks

    def run(self) -> None:
        self.find_peaks()

        # Calculate the widths and areas of the detected peaks
        self.calculate_widths()
        self.calculate_areas()

    def find_peaks(self) -> None:
        """
        Detects significant peaks in the signal based on the height threshold.
        """
        peak_indices, _ = find_peaks(
            self.detector.signal.magnitude,
            height=self.height_threshold
        )

        peak_heights = self.detector.signal[peak_indices]

        self.peaks = [
            Peak(
                times=self.detector.time,
                signal=self.detector.signal,
                index=idx,
                height=height,
                width=None
            ) for idx, height in zip(peak_indices, peak_heights)
        ]

    def calculate_widths(self) -> None:
        """
        Calculates the widths of the detected peaks at half maximum height.
        Widths are calculated only after peaks are detected using the `find_peaks` method.
        """
        if not self.peaks:
            raise ValueError("No peaks detected. Run 'find_peaks()' before calculating widths.")

        peak_indices = [np.where(self.detector.time == peak.time)[0][0] for peak in self.peaks]

        widths = peak_widths(
            self.detector.signal.magnitude,
            peak_indices,
            rel_height=0.5
        )[0]

        dt = self.detector.time[1] - self.detector.time[0]  # Time step
        for peak, width in zip(self.peaks, widths):
            peak.width = width * dt

    def calculate_areas(self) -> None:
        """
        Calculates the areas under the detected peaks using the signal data.
        Requires that peak widths have already been calculated.
        """
        if not self.peaks:
            raise ValueError("No peaks detected. Run 'find_peaks()' and 'calculate_widths()' before calculating areas.")

        for peak in self.peaks:
            if peak.width is not None:
                peak.calculate_area(self.detector.signal, self.detector.time)

    def display_features(self) -> None:
        """
        Displays the extracted features of the detected peaks, including height, width, and area
        in a tabular format using the tabulate library.
        """
        from tabulate import tabulate
        # Header for the table
        headers = ["Peak", "Time [s]", "Height", "Width", "Area"]

        # Collect peak data
        table = []
        for i, peak in enumerate(self.peaks):
            table.append([
                i + 1,  # Peak number
                f"{peak.time:.2e~#P}",  # Time
                f"{peak.height:.2e~#P}",  # Height
                f"{peak.width:.2e~#P}" if peak.width is not None else "Not calculated",  # Width
                f"{peak.area:.2e~#P}" if peak.area is not None else "Not calculated"  # Area
            ])

        # Display the table
        print(f"\nNumber of detected peaks: {len(self.peaks)}")
        print(tabulate(table, headers=headers, tablefmt="grid"))

    def _add_to_ax(self, ax: plt.Axes) -> None:
        """
        Adds the signal, detected peaks, and peak widths to the provided matplotlib axis.

        Parameters
        ----------
        ax : plt.Axes
            Matplotlib axis where the signal and peaks will be plotted.
        """
        ax.plot(self.detector.time.magnitude, self.detector.signal.magnitude, label='Signal')

        for peak in self.peaks:
            ax.plot(peak.time.magnitude, peak.height.magnitude, 'x', label='Peaks')
            ax.vlines(
                x=peak.time.magnitude,
                ymin=0,
                ymax=peak.height.magnitude,
                colors='r'
            )

            if peak.width:
                where = (self.detector.time >= peak.time - peak.width / 2) & (self.detector.time <= peak.time + peak.width / 2)

                ax.fill_between(
                    x=self.detector.time.magnitude,
                    y1=0,
                    y2=self.detector.signal.magnitude,
                    where=where,
                    color='red',
                    alpha=0.3,
                    label='Width at Half-Max'
                )

        # Deduplicate legend labels
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        ax.legend(by_label.values(), by_label.keys())

        ax.set(
            title='Pulse Analysis',
            xlabel='Time [seconds]',
            ylabel='Signal Amplitude'
        )

    def plot(self) -> None:
        """
        Plots the signal with detected peaks and widths at half-maximum, if available.
        """
        with plt.style.context(mps):
            fig, ax = plt.subplots(1, 1, figsize=(10, 5))
            self._add_to_ax(ax=ax)
            plt.show()
